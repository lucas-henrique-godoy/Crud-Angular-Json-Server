						**PROJETO CRUD ANGULAR E JSON SERVER - CADASTRO DE PRODUTOS

Tecnologias utilizadas:
- Angular CLI: 9.1.15
- Node: 12.22.12
____________________________________________________________________________________________________________________________________________________
		
#SE√á√ÉO - BACKEND DO PROJETO

- Criar uma pasta raiz para o projeto, neste caso foi crud.

- Dentro da pasta crud, criar uma pasta chamada backend.

-Dentro da pasta backend, rodar o comando para criar o arquivo package.json, que contem as depend√™ncias do projeto, com os valores padr√£o: npm init -y.

-Tamb√©m dentro da pasta backend, rodar o comando npm i json-server: instala localmente na pasta o pacote json-server, que permite criar uma API REST fake rapidinho para testes e prototipa√ß√£o, e j√° o coloca no arquivo package.json criado anteriormente.

-Dentro da pasta backend, criar  arquivo db.json, onde criamos um objeto, e dentro deste objeto vai ter todos os endpoints da API. Criou 3 objetos(produtos) com as propriedades de id, nome, pre√ßo. O arquivo db.json funciona como um banco de dados fake quando usado com o json-server. Ele simula uma API REST completa (com rotas GET, POST, PUT, DELETE) sem precisar de backend real. √â √∫til para testes e prot√≥tipos de frontend.

-Dentro do arquivo package.json criou um script para iniciar o db.json. Comando: 
"scripts": {
    "start": "json-server --watch db.json --port 3001"    
  },

Basicamente esse script chama o json-server que foi instalado anteriormente, colocou para ele ficar monitorando o arquivo db.jon na porta 3001. Agora a API esta funcional.

-Dentro da pasta backend, colocar o comando npm start para rodar a API.

____________________________________________________________________________________________________________________________________________________
*TIVE UM ERRO DEPOIS DE CRIAR O DB.JSON E RODAR A API:

‚úÖ Resumo do erro e solu√ß√£o
Erro:
Voc√™ recebeu o erro SyntaxError: Unexpected token '?' ao rodar npm start. Isso aconteceu porque o pacote json-server usa o operador ?? (nullish coalescing), que n√£o √© suportado pelo Node.js 12, a vers√£o que voc√™ est√° usando.

Causa:
Seu Node.js est√° desatualizado (vers√£o 12), e o json-server instalado foi desenvolvido para vers√µes mais recentes do Node (14+).

Solu√ß√£o aplicada:
Desinstalamos a vers√£o atual do json-server e instalamos uma vers√£o mais antiga e compat√≠vel com Node 12, assim:

-Desinstala a vers√£o atual do json-erver: npm uninstall json-server

-Instala avers√£o do jso-server compat√≠vel com o Node 12: npm install json-server@0.16.3 --save-dev

Depois disso, npm start funcionou corretamente com a sua vers√£o atual do Node.js.
____________________________________________________________________________________________________________________________________________________

			# SE√á√ÉO - FRONTEND DO PROJETO

**VIS√ÉO GERAL ANGULAR

- O que √© Angular? Um framework JavaScript desenvolvido pelo Google para cria√ß√£o de aplica√ß√µes Web SPA(Single Page Application) baseada em componentes.

- Command Line Interface(CLI)- Interface de linha de comando do Angular. Para instalar rodar  comando: npm i -g @angular/cli.

-Para criar um novo projeto Angular, rodar o comando: ng new minha-app.

- Typescript: Linguagem criada pela Microsoft, que √© um superset do JavaScript, onde possu√≠ todas as funcionalidades do JavaScript, mas tem outras como Tipagem Forte e √© Orientada a Objetos. No Angular, o c√≥digo escrito em Typescript √© compilado para JavaScript.
----------------------------------------------------------------------------------------------------------------------------------------------------

**√Årvore de Componentes: A partir do componente principal(raiz ou pai) que no Angular normalmente se chama app.component, voc√™ referencia outros componentes como: Formul√°rio, Header, um componente de navega√ß√£o, um componente que representa o conte√∫do, etc.
____________________________________________________________________________________________________________________________________________________

**Conceitos Essenciais- Inicializa√ß√£o da Aplica√ß√£o:

- Arquivo main.ts: √â o primeiro arquivo que ser√° chamado para inicializar a aplica√ß√£o Angular.

- Arquivo app.module: Arquivo que √© chamado pelo main.ts para inicializar a aplica√ß√£o. A aplica√ß√£o Angular √© organizada em componentes, ou seja uma grande √°rvore de componentes. Esses componentes s√£o organizados dentro de m√≥dulos, a aplica√ß√£o √© modularizada. Os m√≥dulos por sua vez, nos d√£o alguns "poderes", como por exemplo criar determinados componentes que est√£o vis√≠veis apenas dentro do m√≥dulo. Isso traz um maior n√≠vel de encapsulamento. Exemplo: Imagine que voc√™ tem um determinado componente que √© um componente que n√£o pode ser usado fora de determinada situa√ß√£o(ele n√£o pode ser usado no sistema inteiro), ent√£o podemos coloca-lo dentro de um m√≥dulo e ele ficar vis√≠vel apenas dentro daquele m√≥dulo. Dentro do arquivo app.module tem a um atributo chamado bootstrap que tamb√©m serve para inicializar a aplica√ß√£o e aponta para o app.component que √© o que √© criado por padr√£o.

- Arquivo app.component: √â o componente que √© criado por padr√£o, onde a partir dele  toda a √°rvore de componentes ser√° chamada.
____________________________________________________________________________________________________________________________________________________
**O que √© um componente? √â como um peda√ßo da aplica√ß√£o, um trecho de c√≥digo que representa um componente visual da sua tela. Um componente √© composto por um arquivo HTML, CSS e TS. Ou seja,  estrutura(HTML), estilo(CSS), comportamento(TS). Quando um componente √© criado, √© gerado uma tag personalizada, exemplo o componente home.component gera a tag <app-home><app-home>,essa √© a forma para referenciar todo o c√≥digo HTML, CSS  e TS que foi criado. A ideia √© encapsular dentro desse componente as tr√™s tecnologias da WEB.

-Arquivo TS: √â o arquivo de comportamento do componente, a partir dele √© que o Angular ir√° encontrar os arquivos HTML e CSS, pois ele faz uma referencia, ent√£o quando criamos um componentes pelo menos devemos ter o arquivo TS.

**Organiza√ß√£o Usando M√≥dulo: O Angular n√£o organiza a aplica√ß√£o somente em componentes, mas tamb√©m em m√≥dulos, isso significa que todos os componentes ir√£o estar dentro de algum m√≥dulo, seja um √∫nico m√≥dulo para toda a aplica√ß√£o, como numa aplica√ß√£o pequena todos os componentes podem ficar dentro de app.module(m√≥dulo principal criado por padr√£o), como √© o caso deste projeto. Mas podemos organizar nossa aplica√ß√£o em diversos m√≥dulos. Desse modo, quando voc√™ criar um componente dentro do m√≥dulo, voc√™ tem a escolha de dizer se aquele componente ficar√° vis√≠vel para fora do m√≥dulo, ou seja algu√©m de fora do m√≥dulo pode referenciar aquele componente, ou seja ,voc√™ pode dizer que aquele componente vai ficar vis√≠vel  apenas dentro do m√≥dulo.
----------------------------------------------------------------------------------------------------------------------------------------------------
**Anatomia do m√≥dulo: 

- Dentro do arquivo app.module tem 5 atributos: Declarations, Imports, Exports, Providers, Bootstrap.

O que devemos colocar dentro de cada um desses atributos?

-Declarations: Declara todos os componentes que fazem parte daquele m√≥dulo; declarar diretivas que fazem parte daquele m√≥dulo; declarar os pipes que fazem parte daquele m√≥dulo. Neste projeto, ser√° usado para declarar principalmente os componentes que fazem parte daquele m√≥dulo. Quando dizemos que um componente faz pat√™ de um m√≥dulo, n√£o necessariamente ele √© vis√≠vel para fora do m√≥dulo, voc√™ deve colocar esse componente tamb√©m dentro de exports.

-Imports: Serve para importar outros m√≥dulos, ou seja, um m√≥dulo pode depender de outro m√≥dulo, podendo ser um m√≥dulo da pr√≥pria aplica√ß√£o ou um m√≥dulo externo. Podemos importar depend√™ncias e bibliotecas.

-Exports: Serve para declarar componentes, diretivas e pipes que podem ser vis√≠veis para fora do m√≥dulo.

-Providers: Serve para declarar os services.

-Bootstrap: √â onde tem a refer√™ncia do componente principal que ser√° carregado, sendo necess√°rio apenas para 1 √∫nico m√≥dulo, que √© o m√≥dulo inicial da aplica√ß√£o, o app.module. No caso do app.module, n√£o precisamos exportar nada, os outros m√≥dulos √© que v√£o exportar para o app.module utilizar, ou seja o app.module importa os outros m√≥dulos.

----------------------------------------------------------------------------------------------------------------------------------------------------
-OBS: Quando dizemos que um componente faz parte de um m√≥dulo, n√£o necessariamente ele √© vis√≠vel para fora do m√≥dulo. Para tornar um componente vis√≠vel para fora do m√≥dulo, ele deve ser colocado dentro de exports. 
-Quando criamos um componente ele j√° √© registrado dentro de app.module automaticamente, ou seja se estamos trabalhando dentro de um m√≥dulo app.module, s√≥ vai ser poss√≠vel usar componentes que estejam carregados dentro do ap.module.


**DECORATOR: √â um padr√£o de projeto eu tem como objetivo evitar heran√ßa, o inv√©s de trabalhar como heran√ßa, voc√™ trabalha com composi√ß√£o para estender um determinado objeto. Exemplo: @Directive, @NgModule, @Component, etc. O Angular usa para definir que aquele classe exerce algum tipo de papel dentro do framework. Exemplo: Se queremos que uma classe seja um componente, usamos o @Component.
____________________________________________________________________________________________________________________________________________________
**Instalando e criando projeto Angular

-Instalando a cli do Angular. Comando: npm i -g @angular/cli

- Criando um projeto Angular: ng new nome-projeto
- Criando um projeto Angular sem arquivos desnecess√°rios como arquivos de teste: ng new nome-projeto --minimal
- Rodar o projeto Angular: ng serve ou npm start, ambos funcionam.
- Instalando a depend√™ncia do Angular Material: ng add @angular/material
- Criar um componente: ng generate componente nome-do-componente
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Arquivos dentro de um projeto Angular:

- Arquivo angular.json: Possui algumas configura√ß√µes do Angular.
‚úÖ Explica√ß√£o Corrigida e Completa:
Dependendo da vers√£o do Angular (e tamb√©m das configura√ß√µes padr√£o do projeto), ao gerar um novo componente com o Angular CLI (ng generate component), os arquivos de template (HTML) e estilo (CSS/SCSS) podem ser criados dentro do pr√≥prio arquivo .ts ‚Äî o que √© chamado de inline template e inline style. Para alterar esse comportamento padr√£o, voc√™ pode configurar o arquivo angular.json (ou workspace.json, dependendo da estrutura do projeto), adicionando ou modificando as seguintes op√ß√µes:

"@schematics/angular:component": {
  "inlineTemplate": false,
  "inlineStyle": false
}
O que isso faz:
"inlineTemplate": false ‚Üí Garante que o Angular CLI crie um arquivo HTML separado.

"inlineStyle": false ‚Üí Garante que o Angular CLI crie um arquivo CSS/SCSS separado.

Observa√ß√£o importante:
Essa configura√ß√£o define o comportamento padr√£o para quando voc√™ gerar componentes. No entanto, voc√™ ainda pode sobrescrever isso com flags no comando, por exemplo:

ng generate component nome-do-componente --inline-template --inline-style
Ou para desativar inline no comando (mesmo que esteja ativado por padr√£o):

ng generate component nome-do-componente --inline-template=false --inline-style=false 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Arquivo assets: Serve para colocar arquivos est√°ticos, arquivos de imagem e  fontes.
- Arquivo Enviroments: Local onde √© colocado as vari√°veis de ambiente.
_______________________________________________________________________________________________________________________________________________________________________

- Nesta etapa depois de criar o componente de Header,  n√≥s iremos importar dentro do  app.module o MatToolbarModule(barra de ferramentas). Estilizamos o header tamb√©m.
- Criamos e estilizamos tamb√©m o componente footer. Aqui foi usado tamb√©m o MatToolbar.
- Criamos e estilizamos o componente NAV(navega√ß√£o). E iImportei o MatSidenavModule e o MatListModule dentro de app.modulepara usar no componente nav.
_______________________________________________________________________________________________________________________________________________________________________


			# SE√á√ÉO - ELEMENTOS DO ANGULAR - Mini Curso: Componentes, Rotas, Diretivas, Pipes, Observables, Services, Inje√ß√£o de Depend√™ncia.


**COMPONENTE ANGULAR: √â formado em via de regra por 3 partes: HTML, CSS, TS. N√£o necessariamente precisamos ter estilo no componente. Tamb√©m n√£o √© obrigat√≥rio ter o arquivo HTML,  podemos colocar o template dentro do arquivo TS. Existe um escopo("mundo") dentro do componente, ou seja, o componente tem o seu pr√≥prio "mundo" interno, como e fosse uma pequena aplica√ß√£o. Exemplo: Se aplicarmos um estilo CSS em um seletor gen√©rico(link, titulo, etc), esta estiliza√ß√£o ser√° aplicada somente dentro do componente. Existem os arquivos globais, onde s√£o aplicados regras que valem para todos os componentes(index.html, styles.css, etc).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**DIRETIVAS DE ATRIBUTO: Altera apar√™ncia(CSS) e o comportamento de um elemento, componente ou outra diretiva. Exemplo: alguma a√ß√£o dentro de um bot√£o, mudar a cor de algo, etc.

-EXEMPLO DE C√ìDIGO DE UMA DIRETIVA DE ATRIBUTO:

@Directive({
    selector: '[appRed]'
})
export class RedDirective {
    constructor(el: ElementRef) {
        el.nativeElement.style.color = '#e35e6b';
    }
}

- A Diretiva acima, esta pegando o elemento da DOM, pegando atributo style e color(dentro de style), e alterando a cor para vermelho.



-USO DA DIRETIVA NO HTML:
<i class="material-icons v-middle" appRed>  -Aqui a Diretiva altera a cor do √≠cone para vermelho.
    favorite
</i>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**DIRETIVAS ESTRUTURAIS: Altera layout adicionando e removendo elementos da DOM(estrutura da p√°gina/HTML). A diferen√ßa visual entre a diretiva de atributo para a estrutural, √© eu a diretiva estrutural usa asterisco na frente. Exemplo: *ngIf, *ngFor.

-EXEMPLO DE C√ìDIGO DE UMA DIRETIVA ESTRUTURAL:

<form *ngIf="product" class="product-form">   

</form>

-Aqui ir√° exibir ou n√£o o elemento formul√°rio se o produto estiver definido/setado. Aqui ele  altera a estrutura, porque ele ir√° ou suprimir um determinado elemento ou  mostrar, de acordo com a express√£o colocada no *ngIf. Ou seja, estamos fazendo uma condicional baseada em uma vari√°vel, ele ir√° mostrar o formul√°rio se o produto estiver setado, ou ele simplesmente vai remover o formul√°rio da DOM caso produto n√£o esteja setado. Por isso √© uma diretiva estrutural, pois ir√° mexer na DOM, vai remover um elemento caso a express√£o seja falsa.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

<ul>
    <li *ngFor="let product of products">   
        {{ product.name }}
    </li>
</ul>

- Aqui ele ir√° acrescentar novos elementos. Temos uma UL(lista-n√£o-ordenada) com LI,  e a partir desse LI ele ir√° fazer um la√ßo FOR em cima  dos produtos, se tiver 10 produtos ele vai repetir o LI 10 vezes mostrando os nomes dos produtos. Esta diretiva estrutural ira adicionar novos elementos na DOM de acordo com a lista de produtos.
_______________________________________________________________________________________________________________________________________________________________________

**PROPERTY BININDG(BINDING DE ATRIBUTO): √â uma das formas de comunica√ß√£o entre o arquivo TS e o HTML dentro do componente. Binding quer dizer liga√ß√£o,  e assim usando os colchetes associados a um atributo, ele vai fazer a liga√ß√£o e pegar nome que colocamos na propriedade no HTML,  e vai procurar uma vari√°vel com esse nome, e ai sim ele pega o valor da vari√°vel e associa ao dataSource que √© um atributo de tabela. O Material Design usa esse dataSource com mais frequ√™ncia para renderizar tabelas.

-EXEMPLO DE PROPERTY BINDING:

HTML:
<table [dataSource]="products">  
    
</table>

-Aqui o atributo dataSource ir√° no TS buscar a vari√°vel products que √© uma lista(Array) e usar essa vari√°vel para montar a tabela. O dataSource deve estar dentro de colchetes para funcionar.


TS:
@Component({
    selector: 'app-product-read',
    templateUrl: './product-read.compnent.html',
    styleUrl: ['./product-read.component.css']			
})
export class ProductReadComonent
implements OnInit {

    products: Product[];  -Aqui definimos uma  vari√°vel que √© uma lista de produtos no TS,  e ser√° usada pelo dataSorce para construir a tabela no HTML.
}

_______________________________________________________________________________________________________________________________________________________________________

**EVENT BINDING: Usado para fazer liga√ß√£o entre um evento do HTML pra um m√©todo que esta no arquivo TS. Para fazer isso √© usado a sintaxe dos par√™nteses.

-EXEMPLO DE EVENT BINDING:

HTML:
<button mat-raised-button (click)="createProduct()" color="primary"> - Aqui √© a chamada do m√©todo que esta no TS por meio de um evento click, dentro de par√™nteses.
    Salvar
</button>


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    createProduct() {    - Aqui √© o m√©todo criado no TS que ser√° chamado no HTML pelo evento de click.
        //...
    }
}
_______________________________________________________________________________________________________________________________________________________________________

**ONE WAY DATA BINDING(DATA BINDING DE UMA √öNICA DIRE√á√ÉO): One-Way Data Binding (liga√ß√£o de dados unidirecional) significa que os dados v√£o de um √∫nico sentido: do componente(TS) para a view (HTML). √â quando voc√™ exibe dados na tela, mas n√£o os altera diretamente a partir da tela. A view apenas reflete o estado do componente. Imagine que no HTML voc√™ tem um input de nome,  e l√° no arquivo TS voc√™ tem uma vari√°vel chamada nome. Vamos supor que voc√™ coloque na vari√°vel nome o valor Rebeca(nome = "Rebeca"). Por conta do  One-Way Data Binding, ele ir√° aplicar esse nome(Rebeca) para o Input no HTML mostrando o nome Rebeca.
Vamos supor que houvesse uma outra mudan√ßa na vari√°vel do TS de Rebeca para Ana, ele vai mandar uma notifica√ß√£o e atualizar o componente para Ana, porque o valor da vari√°vel no TS mudou.

-EXEMPLO DE ONE WAY DATABINING(EXPLICADO ACIMA):

HTML:
<input [value]="nome">  -Aqui mostra o valor que for colocado na vari√°vel do TS. Tem que usar colchetes pois √© um binding de atributo.


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    nome: string = "Rebeca";  	-Vari√°vel que √© mostrada no input, se mudar o valor, l√° tamb√©m muda.  
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**TWO WAY DATA BINDING(DATA BINDING DE DUAS DIRE√á√ïES): Two-Way Data Binding significa que os dados v√£o do componente (TS) para a view (HTML) e tamb√©m da view (HTML) de volta para o componente (TS), ou seja, qualquer altera√ß√£o feita na vari√°vel do componente ser√° refletida automaticamente na tela, e qualquer altera√ß√£o feita na tela (como digitar em um input) atualizar√° a vari√°vel no componente. √â muito usado no Angular quando trabalhamos com formul√°rios. Exemplo: Criar usu√°rio, Alterar usu√°rio. Assim tanto se alterarmos no HTML, como no c√≥digo Typescript, os dados v√£o  ficar sincronizados.   

-EXEMPLO DE TWO WAY DATABINING(EXPLCIAOD ACIMA):

HTML:
<input [(ngModel)]="nome"> -Essa √© a sintaxe para se usar o Two Way Data Binding, assim os dados podem ser alterados tanto no HTML quanto no TS.


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    nome: string = "Rebeca";  	-Vari√°vel que √© mostrada no input, se mudar o valor, l√° tamb√©m muda e vice versa.  
}

_______________________________________________________________________________________________________________________________________________________________________

**ANGULAR ROUTER: O Angular Router √© o sistema de navega√ß√£o de p√°ginas do Angular.
Ele permite que voc√™ troque de componentes na tela sem recarregar a p√°gina, como se fosse um site de v√°rias p√°ginas ‚Äî mas tudo acontece dentro do Angular.
üß† Por que usar? Imagine um app com v√°rias "telas": Home, Produto, Usu√°rio, voc√™ n√£o quer criar um HTML diferente para cada um, mas sim mudar o conte√∫do dinamicamente. √â isso que o Angular Router faz. Ele funciona com rotas: voc√™ define qual componente deve ser mostrado quando o usu√°rio acessa uma determinada URL.
 
-Por exemplo, quando o usu√°rio clica o menu HOME e a URL HOME √© selecionada, automaticamente o componente HOME vai ser carregado no Router Outlet que √© um componente que faz parte do Angular Router, onde ir√° injetar dentro dele os componentes de acordo com a navega√ß√£o que foi feita. O que vai dizer a navega√ß√£o √© exatamente a URL do componente que foi mapeada, como houve um mapeamento de /home para o componente Home, automaticamente quando voc√™ navega para ele, ele vai colocar o componente no local especificado que voc√™ disse. Se o usu√°rio for l√° e navegar para /produto, automaticamente ele vai trocar os componentes e vai carregar nesse mesmo local que voc√™ previamente definiu com o componente do Router(Router-Outlet) ele vai substituir o produto. Da mesma forma se o usu√°rio for l√° e navegar para /usu√°rio, seja clicando o menu ou mesmo colocando direto na URL, ele vai substituir o componente produto pelo componente usu√°rio. Ent√£o sempre que voc√™ for navegando na sua aplica√ß√£o, basicamente vai ter um mapeamento entre a rota e o componente, e ai tendo um mapeamento entre a rota e o componente ele coloca dentro desse elemento no Router Outlet o componente selecionado a partir da rota.

-EXEMPLO DE ROUTER:

HTML:
<a routerLink="/products"> -Link da URL da rota do componente onde o usu√°rio poder√° acessar na aplica√ß√£o.
  Produtos
</a>


TS:
const routes: Routes = [{
  path: "products",   			- Aqui √© definido a rota para o componente products. Path √© o caminho.
  componente: ProductCrudComponent 
}, {
  path: "products/create",
  component: ProductCreateComponent
}]; 


ROUTER OUTLET:
<mat-sidenav-content>
  <router-outlet></router-outlet> -Aqui dentro de <router-outlet></router-outlet> √© onde as rotas ser√£o carregadas.
</mat-sidenav-content>
_______________________________________________________________________________________________________________________________________________________________________

**PIPES: S√£o processamentos que voc√™ faz em cima de vari√°veis. Ou seja, voc√™ pode usar pipes para fazer a formata√ß√£o de dados. Por exemplo, digamos que  eventualmente o formato que voc√™ recebeu de um banco de dados, n√£o √© o formato que voc√™ quer exibir, e para isso voc√™ ode usar um pipe para formata√ß√£o de um dado. Por exemplo, eu recebi um valor num√©rico e eu quero formatar esse valor como um valor de moeda, em real colocando o s√≠mbolo de real e quero colocar duas casas decimais. Ent√£o voc√™ pode passar esse valor e colocando um pipe | (barra reta), onde ter√° um m√©todo que ser√° chamado e ir√° processar esse valor para transformar esse dado o formato que voc√™ quer. 

-EXEMPLO DE PIPE:
<p>
    O vencimento √© 
    {{ produto.vencimento | date }}
</p>
----------------------------------------------------------------------------------------------------------------------------------------------------

-EXEMPLO DE PIPE COM PAR√ÇMETRO:
<td mat-cell *matCellDef="let product">
    {{ product.price | currency: 'BRL' }}
</td>

 -Aqui estamos exibindo a propriedade price do objeto product, utilizando o pipe currency para formatar o valor como uma moeda.
O par√¢metro 'BRL' indica que a moeda usada deve ser o Real brasileiro (R$).
Ou seja, o valor ser√° exibido no formato de moeda brasileira, como por exemplo: R$ 1.000,00.

üìå Observa√ß√µes extras (se quiser aprofundar):
Se voc√™ n√£o passar par√¢metro, o Angular usa a moeda padr√£o do sistema.

√â poss√≠vel tamb√©m passar mais par√¢metros para personalizar, como o n√∫mero de casas decimais.

Exemplo com mais op√ß√µes:

{{ product.price | currency:'BRL':'symbol':'1.2-2' }}
Mostra o s√≠mbolo da moeda e sempre com duas casas decimais (ex: R$ 1.000,00).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

-EXEMPLO DE UMA CADEIA DE PROCESSAMENTO/CADEIA DE PIPES- Tamb√©m chamada de CHAINING:
<p>
    O vencimento √© 
    {{ produto.vencimento | date: 'fullDate' | uppercase }}
</p>

-Essa cadeia de pipes formata a data de vencimento (produto.vencimento) para o formato completo (fullDate) e depois transforma o texto todo em letras mai√∫sculas (uppercase).
_______________________________________________________________________________________________________________________________________________________________________
**PROGRAMA√á√ÉO REATIVA(REACTIVEX): O Angular usa esse framework ReactiveX que trabalha com conceitos de programa√ß√£o reativa. Programa√ß√£o reativa tem o conceito de o c√≥digo s√≥ ser√° chamado de forma reativa, ou seja, precisa acontecer alguma coisa externa, no caso um evento para dai quando acontecer isso o c√≥digo ser executado.

-IMPORTA√á√ÉO DO OBSERVABLE NO ANGULAR: import { Observable } from "rxjs";

*O PADR√ÉO OBSERVER: √â o padr√£o de projeto mais utilizado na web. Tudo come√ßa a partir do padr√£o Observer. √â um padr√£o orientado Evento.

-Subject: √â quem tem a capacidade de monitorar e detectar quando um evento acontece.
-Observer: S√£o os c√≥digos que est√£o interessados num determinado evento.

*  O que acontece, se voc√™ tirar a figura do Subject, os observables(quem esta interessado em monitorar os eventos) precisam ficar monitorando os eventos, mas se voc√™ tiver algu√©m que vai ser capaz de monitorar os eventos, voc√™ pode delegar para esse Subject. Exemplo: "Monitore o evento tal, e  quando acontecer o evento me notifique" ou seja, me avise que o evento aconteceu. Por isso os observadores precisam se registrar no Subject dizendo que ele √© interessado no evento, ou seja, para o padr√£o de projeto Observer existir, antes precisa haver um explicito desejo dizer "Eu estou interessado em receber notifica√ß√µes de um determinado evento", ou seja, h√° um registro do  Observador que √© quem est√° interessado  no Subject.
Depois que h√° esse registro o Subject vai detectar o Evento. O Evento aconteceu e ele √© capaz de detectar e perceber que o determinado evento aconteceu, ou seja, uma vez que  Subject detectando que o Evento aconteceu e ele tem dentro dele uma lista de todos os Observadores(Observers) que est√£o interessados de ser notificados, ele vai notificar todos s Observadores dizendo: "O evento que voc√™s estavam esperando aconteceu". Quando o Subject notifica, √© executado uma fun√ß√£o dentro de cada Observador e ai ele vai fazer aquilo que √© necess√°rio de acordo com o evento que foi gerado.
EXEMPLO: Imagine que voc√™ tem um evento de compra, e voc√™ tem um Observador que √© para enviar um email para o usu√°rio. Voc√™ tem outro Observador que √© para dar baixa no estoque, voc√™ tem outro Observador que vai mandar uma mensagem para um outro sistema que via separar mercadoria. E ai aconteceu o evento da venda, algu√©m foi l√° e comprou, e ai o Subject que √© quem est√° monitorando esse evento da compra vai notificar para o Observador de email: "Olha aconteceu uma compra". Ai o Observador de email vai pegar aquela compra e enviar um email pro usu√°rio: "Sua compra foi realizada com sucesso, estamos processando a sua compra e dentro de algumas horas iremos mandar novas notifica√ß√µes com o progresso no seu email". Ai esse evento foi passado para um outro Observador que quer dar uma baixa no estoque, ele vai l√° e manda essa compra, e ele vai ver todos os produtos que est√£o dentro da compra,  e subtrai 1 do estoque. Ai o pr√≥ximo Observador recebe o evento da compra e ele manda para um sistema de separa√ß√£o do produtos que o produto "tal", "tal" e "tal" podem ser separados. Ent√£o percebe-se que o Subject √© quem detecta o evento, mas ele funciona como um intermedi√°rio, l√™ e entende que o evento aconteceu e notifica os interessados.

-EXEMPLO DE ANALOGIA DE OBSERVABLE E SUBJECT-ANIVERS√ÅRIO SURPRESA: Existem 2 personagens nesta hist√≥ria: A namorada que representa o Observer e o Porteiro que representa o Subject. H√° tamb√©m o Evento que √© a chegada do aniversariante. Essa hist√≥ria ter√° 2 possibilidades.

-CEN√ÅRIO 1-SEM  OBSERVER: A namorada n√£o ir√° usar o padr√£o Observer e ela vai ficar de forma proativa na janela olhando os carros chegarem, quando chegar o carro amarelo do namorado, ela vai para dentro da sala e diz "Pessoal ele acabou de chegar, vamos apagaras luzes e ficar em sil√™ncio para a gente fazer a surpresa". Neste primeiro cen√°rio sem um Observer, quem estava interessada no evento(que era namorada), ela ficou parada sem curtir mais a festa olhando na janela at√© que o evento acontecesse para dai ela ser respons√°vel por todo o processo de detectar o evento e avisar todos os convidados.  Neste caso como ela teve uma postura proativa, ficou muito  ruim para ela, porque ela ficou totalmente ocupada em detectar o evento e da√≠ avisar os convidados.

-CEN√ÅRIO 2-COM OBSERVER: A namorada delegou a tarefa de ficar observando para o porteiro, aqui temos o uso do padr√£o Observer, porque o Porteiro √© o Subject. Como ele esta na portaria ele tem a capacidade de detectar o Evento de uma forma muito mais f√°cil, at√© porque o Namorado vai ter que passar pelo pr√©dio ou pela portaria, ent√£o ele tem a posi√ß√£o privilegiada pra detectar o Evento. Ent√£o o eu foi que a Namorada fez? Lembra que a ente disse que precisava fazer  um registro, ou seja o Observer que √© o interessado, ele precisa se registrar om o Subject para dizer "Eu estou interessado em receber o Evento", para a Namorada avisar o Porteiro de que ele precisa ficar observando o Evento, ela precisou interfonar e pedir: "Voc√™ tem como observar a chegada do carro amarelo?", ai o Porteiro disse: "Ok, deixa comigo que assim eu o Evento acontecer eu notifico voc√™s de volta". Ou seja, esse notificar de volta, √© o Porteiro depois de olhar e perceber que o Evento aconteceu e detectar o Evento, ele vai interfonar de volta dizendo que o Evento aconteceu, s√≥ ent√£o a Observadora que √© a Namorada que √© interessada pelo Evento ela vai fazer todo o procedimento para que o aniversario surpresa acontecer.
Ent√£o 1¬∫ A Namorada precisou ligar pro Porteiro se registrando dizendo "Olha estou interessada no Evento X", o Porteiro deu um OK dizendo: "Pode deixar comigo, quando acontecer o Evento eu notifico de volta", da√≠ o conceito de CALLBACK(chamada de volta) para notificar que o Evento aconteceu. Ent√£o ele liga de volta dizendo: "O Evento aconteceu", ai a Namorada  que j√° estava curtindo a festa e que n√£o estava mais preocupada em ficar olhando pela janela, foi l√° recebeu a notifica√ß√£o do Porteiro e ai sim ela fez todo o trabalho de prosseguir com os preparativos para a surpresa.
Ent√£o deixa bem claro que trabalhar com o padr√£o Observer deixa o Observador que √© o interessado livre para fazer outras coisas e nesse cen√°rio houve uma chamada reativa, ela n√£o estava querendo de forma proativa ficar na janela, ela quis ficar de forma reativa, ela s√≥ vai fazer as coisas quando um determinado Evento acontecer. Por isso que o padr√£o Observer √© um padr√£o orientado a Evento.
----------------------------------------------------------------------------------------------------------------------------------------------------

*ENTENDENDO OBSERVABLES: Do ponto de vista do Javascript puro a gente come√ßa a trabalhar com esse conceito de reatividade a partir de que voc√™ tem a possibilidade de passar uma fun√ß√£o como par√¢metro para outra fun√ß√£o, e essas fun√ß√µes s√£o chamadas tamb√©m de CALLBACKS. Por exemplo: Voc√™ passa uma fun√ß√£o para outra fun√ß√£o como par√¢metro para outra fun√ß√£o dizendo: "Eu quero que voc√™ invoque essa fun√ß√£o que eu estou passando como par√¢metro, quando a resposta a requisi√ß√£o chegar". E ai ele vai l√° e chama a CALLBACK. Um dos problemas da CALLBACK √© quando voc√™ tem uma logica mais complexa e voc√™ vai acabar caindo num cen√°rio que voc√™ precisa passar uma CALLBACK dentro de outra CALLBACK(CALLBACK HELL), uma  fun√ß√£o dentro da outra, tornando assim o c√≥digo de dif√≠cil leitura e tamb√©m de dif√≠cil manuten√ß√£o. Quanto mais outras CALLBACKS, outras logicas fossem adicionadas ficava ainda mais complicados a c√≥digo.

-A partir do ECMA Script 2015 surgiu um conceito de Promises onde tamb√©m s√£o usados os CALLBACKS, mas na Promisse tem a capacidade de encadear as varias chamadas, voc√™ consegue compor melhor varias chamadas de Promisses,  sem ter essa quest√£o desse aninhamento que era causado pelo CALLBACK. Quais os problema da Promisse? A Promisse voc√™ usa apenas uma √∫nica vez. Se voc√™ executou um determinado c√≥digo usando Promisse, depois que termina voc√™ n√£o consegue reutilizar essa Promisse. E como evolu√ß√£o da Promisse, que voc√™ consegue ter os mesmos benef√≠cios de ser f√°cil a composi√ß√£o, voc√™ consegue chamar varias fun√ß√µes encadeadas numa forma simples, s√≥ que com outros benef√≠cios, voc√™ tem o Observable.

-Os Observables que est√£o dentro do RXJS que o Angular usa como depend√™ncia, possuem algumas vantagens por exemplo: 
1- Um Observable diferente da Promisse voc√™ consegue reusar ele.

2- Consegue lidar com um STREAM DE DADOS, vamos supor que voc√™ precisa ficar monitorando uma determinada vota√ß√£o presidencial, e voc√™ pode criar um Observable para ficar de tempo em tempos consumindo essa informa√ß√£o do servidor, ou seja, com um √∫nico Observable voc√™ consegue ficar recebendo uma STREAM DE DADOS. Exemplo: "Foram apurados 20% da urna onde um candidato esta com 50% e outro esta com 50%". Daqui a pouco chega mais informa√ß√µes dizendo "Foram apuradas 40% das urnas e agora um candidato esta com 60%e o outro esta com 40%", depois chegam mais dados. E com 1 √∫nico Observable voce fica recebendo esse STREM DE DADOS, ou seja, um conjunto de dados em sequencia, sem necessariamente ficar criando novos objetos porque voce consegue reusar.

3- Operadores: As Promises tamb√©m tem um outro "poder" que s√£o os Operadores, que s√£o fun√ß√µes que podem ser usadas juntamente com os Observables. Por exemplo no caso da Promisse voc√™ tem basicamente o m√©todo then. No caso dos Obsevables voc√™ tem outros m√©todos como map. Voc√™ consegue fazer filtros que s√£o tipo de fun√ß√µes(Operadores) que voc√™ consegue trabalhar com os seus dados. Por exemplo:  Eu acabei de receber uma lista de produtos do meu backend, voc√™ te como ficar trabalhando com esses dados a partir dos Observables de uma maneira muito interessante. Ent√£o tem uma serie de fun√ß√µes que ajudam a processar os dados. Em outras palavras por tr√°s do Observable ele vai encapsular essa quest√£o do padr√£o Observer. O padr√£o Observer √© a base da programa√ß√£o reativa, ou seja s√≥ tem programa√ß√£o reativa a partir do padr√£o Observer. Quando o evento acontece ai sim √© que o c√≥digo vai de forma reativa agir por conta que um determinado evento que aconteceu.

- Quando voc√™ trabalha com Observable, Promisse ou CALLBACK, via de regra voc√™ esta trabalhando com c√≥digo ass√≠ncrono, ou seja, n√£o h√° um resposta imediata na chamada do seu c√≥digo. Um exemplo claro de chamada ass√≠ncrona, √© quando voc√™ vai fazer uma chamada pro bakend da sua aplica√ß√£o.

EXEMPLO:

criarNoBackend(produto: Produto): Observable<Produto> {
  return this.http.post<Produto>(ths.url,produto);
}

-Esse m√©todo recebe um produto como par√¢metro e faz uma chamada do tipo post para cadastrar esse produto no backend. Foi chamado o m√≥dulo http do Angular que serve para trabalhar com as requisi√ß√µes HTTP. Entretanto o backend da nossa aplica√ß√£o demora as vezes alguns segundos para responder, ent√£o esse m√©todo n√£o ira responder na hora que voc√™ chamou, ele via responder depois de algum tempo no futuro, por isso esse m√©todo retorna um Observable, e esse Observable que ser√° retornado a partir desse m√©todo, podemos passar para ele registrar um Observador(exatamente o que esta acontecendo no c√≥digo abaixo no subscribe). Voc√™ pode registrar um Observador:

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

criarProduto(): void {
  this.criarNoBackend(this.produto).subscribe (() => {
    this.exibirMensagem("Salvo com sucesso!");
})
}

- Neste m√©todo eu chamei o criarNoBackend, passei o produto e como resposta dessa chamada eu recebo um Observable, ou seja,  na hora que eu chamo ele j√° retorna um Observable, s√≥ que a resposta do servidor anda n√£o chegou, por isso que eu chamo o m√©todo subscribe e ai eu passo uma fun√ß√£o para ser chamada quando a resposta do servidor chegar.

-Neste m√©todo esta sendo registrado um Observador, que √© a fun√ß√£o Arrow que esta sendo passada como par√¢metro para o subscribe. Ou seja, o subcribe √© o m√©todo de registro. Neste caso o Observable √© o meu Subject. Ou seja, o Observable tem a capacidade de detectar que um determinado evento aconteceu, que √© o evento da resposta do meu servidor(backend) para minha requisi√ß√£o post que foi feita, e quando essa resposta chegar  m√©todo que eu passei para o subscribe ser√° chamado e ai sim eu posso exibir uma mensagem por exemplo, de que o usu√°rio foi salvo, ou chamar a navega√ß√£o para ir para uma outra tela, ou seja, eu posso fazer qualquer coisa que eu queira em resposta da minha chamada ao backend.
_______________________________________________________________________________________________________________________________________________________________________


**SERVICES: S√£o classes que tem como principal objetivo organizar e compartilhar m√©todos e dados entre componentes. √â poss√≠vel tamb√©m utilizar Services dentro de Diretivas. A ideia √© voc√™ separar responsabilidades.
-Tudo aquilo que diz respeito a responsabilidade de mostrar algo visual na tela diz respeito ao componente. Mas sempre que voc√™ tem regras que n√£o tem respeito diretamente com a parte visual, ou voc√™ quer encapsular o acesso a sua API(o backend da aplica√ß√£o), o ideal √© voc√™ separar as responsabilidades e colocar algumas responsabilidades no Service, porque diz respeito a parte n√£o visual que n√£o tem diretamente uma rela√ß√£o com aquilo que esta sendo exibido na tela, voc√™ tamb√©m pode colocar toda a responsabilidade de acessar o backend da sua aplica√ß√£o. O Angular n√£o te for√ßa a criar os Services, voc√™ pode criar Service com essa ideia tanto de separar responsabilidades, como tamb√©m viabilizar comunica√ß√£o entre componentes. Por exemplo: Eu preciso de uma determinada informa√ß√£o e essa informa√ß√£o precisa ser compartilhada entre o Componente A e o Componente B, onde os componentes n√£o est√£o pr√≥ximos onde n√£o h√° como passar essa informa√ß√£o de um componente para outro, par isso podemos usar Services como uma forma de compartilhar dados e m√©todos entre componentes.

*MOTIVA√á√ÉO PARA O SERVICE: Imagine que temos o Componente 1 que possui seu HTML, CSS,TS. E dentro do TS nos temos um certo conjunto de l√≥gica. E tamb√©m temos o Componente 2 que tamb√©m tem  seu HTML, CSS TS e dentro do TS tamb√©m possui o seu conjunto de l√≥gica. Usamos o Service para colocar as l√≥gicas que n√£o est√£o relacionadas com a parte visual dos componentes e que n√£o s√£o da responsabilidade dos componentes. Nem toda aplica√ß√£o ter√° apenas 1 √∫nico Service com varias logicas dentro, tudo ira depender de voc√™ ter responsabilidades coerentes dentro de um Service. N√£o necessariamente voc√™ precisa ter um √∫nico m√©todo dentro de cada Service, mas voc√™ vai ter um Service respons√°vel por um conjunto coerente de responsabilidades.
-Por exemplo: um cadastro, onde eu vou criar um produto, alterar um produto, excluir um produto, consultar um produto por ID. Voc√™ pode colchoar isso tudo dentro de um Service s√≥, mas voc√™ n√£o vai colocar outras funcionalidades que n√£o dizem respeito ao produtos, como cadastrar um cliente, alterar um cliente ou mexer num fornecedor dentro de um Service que esta focado para trabalhar nas coisas relacionadas aos produtos. Ent√£o √© importante ter esse cuidado de ter Services que tem logicas que tem um coer√™ncia de estar juntas caso n√£o haja essa coer√™ncia voc√™ cria mais de um Service. Para usar o Service dentro de um Componente precisamos usar Inje√ß√£o de Depend√™ncia.

-CRIAR UM SERVICE: ng g s services/product 
Sintaxe: ng g s nome da pasta/nome do service



-EXEMPLO DE UMA CLASSE QUE REPRESENTA UM SERVICE: Aqui o decorator @Injectable significa que essa classe vai ser detectada pelo Angular e ela vai ser poss√≠vel de ser injetada em outras classes.

 O provideIn: "root" significa que existe um injetor(Injector) e esse injetor √© o injetor raiz da nossa aplica√ß√£o. Basicamente s√≥ existe  1 injetor raiz da minha aplica√ß√£o e uma vez definido que o meu produtoService vai ser provido pelo "root", significa que eu vou ter apenas uma √∫nica inst√¢ncia do ProdutoService em toda a minha aplica√ß√£o, ou seja, sempre que eu injetar o meu produtoService dentro de um Componente, Diretiva o Angular vai me devolver a mesma inst√¢ncia.
 

@Injectable({
  provideIn: "root",
})
export class ProductService {
  //...
}


-Quando usamos o comando para criar um Service: ng g s nome da pasta/nome do servisse. No exemplo acima , o nome do arquivo ficaria product.service.ts e o nome da classe ficou ProductService. No Angular existe todo um Guide Line relativo  nomenclatura dos Componentes, Services, Diretivas, ent√£o precisamos ficar atentos o m√°ximo poss√≠vel as Guides Lines porque isso ira nos ajudar a manter o nosso projeto, como se outros desenvolvedores vierem para o projeto eles ir√£o estar muito mais familiarizados porque √© uma forma padr√£o de se usar nomenclatura dentro do Angular.


-OBS: Existe um padr√£o de projeto do Design Pattern chamado Sigleton, que consiste em criar apenas uma √∫nica instancia de uma classe, as vezes criando um construtor privado dependendo da linguagem, ou as vezes criando um m√©todo para devolver essa inst√¢ncia. Como o Angular ele vai  gerenciar a cria√ß√£o do Service e vai ser respons√°vel por gerenciar a cria√ß√£o dos componentes, porque voc√™ n√£o instancia uma classe produtoService, da mesma forma que voc√™ n√£o vai instanciar uma classe correspondente a um componente, voc√™ n√£o vai instanciar um componente. Quem vai fazer todo esse trabalho de instanciar essas classes gerenciadas como: Componente, Diretiva, Service √© o Angular. Ent√£o como o Angular √© respons√°vel por gerenciar a cria√ß√£o desses objetos, ele tamb√©m vai ser respons√°vel por Injetar Depend√™ncia de um objeto no outro, como tamb√©m √© respons√°vel por garantir que uma determinada instancia sempre ser√° devolvida quando voc√™ pedir. Imagine que voc√™ tem um Service e esse Service tem um contador dentro dele, se voc√™ vai l√° e aumenta esse contador para 10 em um determinado Componente A,  quando voc√™ injetar esse Service no Componente B, 
o contador vale 10. E se l√° no Componente B  voc√™ aumentar esse contador para 30, quando voc√™ injetar esse Service novamente dentro do Componente A, o contador agora vale 30. Se voc√™ aumentar esse contador novamente para 130 e voc√™ vai injetar esse Service no Componente C, o contador vale 130, porque estamos sempre trabalhando com a mesma inst√¢ncia do Service uma vez que voc√™ usa o provideIn: "root".
_______________________________________________________________________________________________________________________________________________________________________

**INJE√áAO DE DEPEND√äNCIA: √â um padr√£o no qual a classe recebe as depend√™nciasde uma fonte externa ao inv√©s de criar por conta pr√≥pria.

-Num cen√°rio padr√£o quando uma Classe A precisa de uma Classe B, ouseja, a Classe A vai preisar da Clase B, ent√£o a Classe A vai criar a Classe B. √â muito natural acontecer isso, mas na Inje√ß√£o de Depend√™ncia ha uma invers√£o dessa logica, ou sej, √© um padr√£o onde a classe recebe as depend√™ncias a partir de uma fonte externa ao inv√©s de criar por conta pr√≥pria. Ou seja, a Classe A precisa da Classe B, ao inv√©s da Classe A criar por conta pr√≥pria uma inst√¢ncia da Classe B, a Classe A vai receber a Classe B a partir do construtor ou a partir de algum outro mecanismo como √© o caso da Inje√ß√£o de Depend√™ncia.
Dependendo da linguagem, framework que voc√™ vai usar a forma  de implementar a Inje√ß√£o de Depend√™ncia √© diferente.

-EXEMPLO  DE UM CEN√ÅRIO SEM INJE√á√ÉO DE DEPEND√äNCIA: A classe Carro depende da Classe Motor

CLASSE CARRO   	  ===>                CLASSE MOTOR

class Carro {                          class Motor {}
  motor: Motor

 construtor() {
  this.motor = new Motor()
 }
}

-Neste cen√°rio a Classe Carro depend√™ncia da Classe Motor. Ent√£o nada mais natural dentro do construtor voc√™ instanciar o Motor a parir da linha : ths.motor = new Motor(), ou seja, voc√™ acabou de instanciar um objeto Motor e atribuiu a vari√°vel dentro da Classe Carro, e tal forma de que quando Carro for instanciado o Carro ter√° automaticamente um Motor. Mas quem foi respons√°vel por instanciar o Motor ? Foi a pr√≥pria Classe Carro, ou seja, ai n√£o houve Inje√ß√£o de Depend√™ncia, porque a Classe Carro foi respons√°vel por criar uma instancia da Classe Motor.


- Se por algum motivo a Classe Motor tiver uma altera√ß√£o, por exemplo, onde para criar um objeto Motor eu preciso dizer qual cilindrada aquele Motor tem. S√≥ que uma vez que eu mexi na classe Motor, na Classe Carro gerou um impacto, pois como Carro cria o Motor agora voc√™ obrigatoriamente precisa passar uma cilindrada como par√¢metro para a constru√ß√£o do Motor. Isso faz com que sempre que voc√™ mexa na Classe Motor, voc√™ tamb√©m tenha que alterar a Classe Carro, gerando uma fragilidade, ou seja, a Classe Carro esta muito dependente da Classe Motor.

CLASSE CARRO:
class Carro {
  motor: Motor

  construtor() {
    this.motor = new Motor() --Gera erro aqui.
  }
}


CLASSE MOTOR ALTERADA: Gera um erro na Classe Carro, obrigando que a  Classe  Carro tamb√©m seja alterada.
class Motor {
 cilindrada: number

  construtor(cilindrada: number) {
  this.cilindrada
 }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-EXEMPLO  DE UM CEN√ÅRIO COM INJE√á√ÉO DE DEPEND√äNCIA:

-Uma forma de resolver isso seria passar Motor como par√¢metro para o Carro. Fazendo isso, significa que algu√©m externo, imagina que voc√™ tem uma classe chamada Fabrica e na hora de voc√™ criar o Carro voc√™ cria o Motor, sabe exatamente o que precisa passar para o Motor e ai sim voc√™ passa o Motor constru√≠do para dentro do Carro. Ou seja, uma fonte externa passou a depend√™ncia para dentro do Carro. E ai voc√™ vai ter frameworks que v√£o te ajudar no processo de Injetar Depend√™ncia.

  
class Carro {
  motor: Motor

  construtor (motor: Motor) {  -Passando o Motor como par√¢metro
    this.motor = motor
  }
}

class Motor {
 cilindrada: number

  construtor(cilindrada: number) {
  this.cilindrada
 }
}



-Principalmente no caso do Angular se a gente substituir Carro por Componente e substituir Motor por Service. Quem √© respons√°vel  por criar o Carro, ou seja o Componente , e quem √© respons√°vel por criar  Service √© o Angular, ent√£o ele ser√° capaz de prover essas depend√™ncias pra gente a partir da Inje√ß√£o de Depend√™ncia.

-Dentro do Framework Angular tem um m√≥dulo de Inje√ß√£o de Depend√™ncia, ou seja, h√° um framework dentro do outro. Ent√£o quando voc√™ cria uma classe ProductService e diz que essa classe  √© @Injectable, voc√™ esta dizendo em outras palavras que essa classe ode ser injetada  e ao mesmo tempo que voc√™ coloca um @Injectable voc√™ esta dizendo pro Angular que ele deve considerar essa classe, ele  deve instanciar essa classe para voc√™. 
Ent√£o o Angular vai instanciar essa classe criando uma instancia e ProductService. Num cen√°rio comum eu tenho uma √∫nica instancia, isso n√£o significa que eu n√£o possa ter mais. Mas no cen√°rio da nossa aplica√ß√£o usando provideIn: "root", ele vai ter apenas uma instancia dessa classe para toda a aplica√ß√£o(ProductService). Sempre que injetarmos ProductService ele vai pegar essa √∫nica instancia.
Depois que o Angular instanciar o ProductService, agora ele vai precisar instanciar  o ProductCreateComponent(Componente de cria√ß√£o de produto) porque ele foi referenciado em algum ponto da sua aplica√ß√£o. Quando Angular for gerar uma instancia desse Componente ele ira criar um Componente e vai passar como par√¢metro e injetar o ProductService no Componente.

Ent√£o nos temos o framework(Angular) quando ele instancia ele cria  o ProductService, e quando ele for instancia o Componente(ProductCreateComponent) ele passa o ProductService que √© injetado no Componente. N√£o necessariamente voc√™ vai ter apenas 1 √∫nica instancia do componente, sempre que voc√™ referenciar o componente a partir da sua tag ele vai criar uma nova instancia daquele componente, para cada tag voc√™ vai ter uma instancia. Portanto quem vai ser respons√°vel por criar essas instancias √© o Angular.

Falando a respeito do provideIn: "root". O "root" √© um apelido(alias) para o AppModule, chamado de root injector. Associado ao AppModule, que √© o modulo inicial da aplica√ß√£o, o root injector √© respons√°vel pela inje√ß√£o de depend√™ncia e ele esta associado ao AppModule. Quando voc√™ diz que o seu provideIn vai ser o "root", voc√™ esta dizendo em outras palavras que o provideIn vai ser o AppModule. Como s√≥ tem 1 AppModule dentro da sua aplica√ß√£o, sempre que voc√™ criar alguma coisa que usa @Injectable  provideIn: "root", significa que esse Service por exemplo vai ter apenas uma √∫nica instancia em toda a sua aplica√ß√£o.


*SINGLETON: Services s√£o sigletons(apenas uma √∫nica instncia) dentro do escopo de um injector.

-INJECTOR: Temos 2 grupos de injetores: ModuleInjector(injetor de m√≥dulo), ElementInjector(injetor de elemento).
Quando usamos root, e o root aponta para o AppModule estamos usando o ModuleInjector


-OBS: No lugar de root voc√™ pode colocar a referencia para um modulo. Vamos supor eu voc√™ tenha um m√≥dulo da sua aplica√ß√£o de autentica√ß√£o. Voc√™ criou um modulo chamado authModule e voc√™ quer dentro desse modulo de autentica√ß√£o ter um determinado servi√ßo dentro daquele escopo, ent√£o voc√™ dizer que o provideIn √© o authModule, mas sem as aspas: @Injectable provideIn: authModule.

















