						**PROJETO CRUD ANGULAR E JSON SERVER - CADASTRO DE PRODUTOS

Tecnologias utilizadas:
- Angular CLI: 9.1.15
- Node: 12.22.12
_______________________________________________________________________________________________________________________________________________________________________
		
#SE√á√ÉO - BACKEND DO PROJETO

- Criar uma pasta raiz para o projeto, neste caso foi crud.

- Dentro da pasta crud, criar uma pasta chamada backend.

-Dentro da pasta backend, rodar o comando para criar o arquivo package.json, que contem as depend√™ncias do projeto, com os valores padr√£o: npm init -y.

-Tamb√©m dentro da pasta backend, rodar o comando npm i json-server: instala localmente na pasta o pacote json-server, que permite criar uma API REST fake rapidinho para testes e prototipa√ß√£o, e j√° o coloca no arquivo package.json criado anteriormente.

-Dentro da pasta backend, criar  arquivo db.json, onde criamos um objeto, e dentro deste objeto vai ter todos os endpoints da API. Criou 3 objetos(produtos) com as propriedades de id, nome, pre√ßo. O arquivo db.json funciona como um banco de dados fake quando usado com o json-server. Ele simula uma API REST completa (com rotas GET, POST, PUT, DELETE) sem precisar de backend real. √â √∫til para testes e prot√≥tipos de frontend.

-Dentro do arquivo package.json criou um script para iniciar o db.json. Comando: 
"scripts": {
    "start": "json-server --watch db.json --port 3001"    
  },

Basicamente esse script chama o json-server que foi instalado anteriormente, colocou para ele ficar monitorando o arquivo db.jon na porta 3001. Agora a API esta funcional.

-Dentro da pasta backend, colocar o comando npm start para rodar a API.

______________________________________________________________________________________________________________________________________________________________________________________________________________________
*TIVE UM ERRO DEPOIS DE CRIAR O DB.JSON E RODAR A API:

‚úÖ Resumo do erro e solu√ß√£o
Erro:
Voc√™ recebeu o erro SyntaxError: Unexpected token '?' ao rodar npm start. Isso aconteceu porque o pacote json-server usa o operador ?? (nullish coalescing), que n√£o √© suportado pelo Node.js 12, a vers√£o que voc√™ est√° usando.

Causa:
Seu Node.js est√° desatualizado (vers√£o 12), e o json-server instalado foi desenvolvido para vers√µes mais recentes do Node (14+).

Solu√ß√£o aplicada:
Desinstalamos a vers√£o atual do json-server e instalamos uma vers√£o mais antiga e compat√≠vel com Node 12, assim:

-Desinstala a vers√£o atual do json-erver: npm uninstall json-server

-Instala avers√£o do jso-server compat√≠vel com o Node 12: npm install json-server@0.16.3 --save-dev

Depois disso, npm start funcionou corretamente com a sua vers√£o atual do Node.js.
_______________________________________________________________________________________________________________________________________________________________________

			# SE√á√ÉO - FRONTEND DO PROJETO

**VIS√ÉO GERAL ANGULAR

- O que √© Angular? Um framework JavaScript desenvolvido pelo Google para cria√ß√£o de aplica√ß√µes Web SPA(Single Page Application) baseada em componentes.

- Command Line Interface(CLI)- Interface de linha de comando do Angular. Para instalar rodar  comando: npm i -g @angular/cli.

-Para criar um novo projeto Angular, rodar o comando: ng new minha-app.

- Typescript: Linguagem criada pela Microsoft, que √© um superset do JavaScript, onde possu√≠ todas as funcionalidades do JavaScript, mas tem outras como Tipagem Forte e √© Orientada a Objetos. No Angular, o c√≥digo escrito em Typescript √© compilado para JavaScript.
----------------------------------------------------------------------------------------------------------------------------------------------------

**√Årvore de Componentes: A partir do componente principal(raiz ou pai) que no Angular normalmente se chama app.component, voc√™ referencia outros componentes como: Formul√°rio, Header, um componente de navega√ß√£o, um componente que representa o conte√∫do, etc.
____________________________________________________________________________________________________________________________________________________

**Conceitos Essenciais- Inicializa√ß√£o da Aplica√ß√£o:

- Arquivo main.ts: √â o primeiro arquivo que ser√° chamado para inicializar a aplica√ß√£o Angular.

- Arquivo app.module: Arquivo que √© chamado pelo main.ts para inicializar a aplica√ß√£o. A aplica√ß√£o Angular √© organizada em componentes, ou seja uma grande √°rvore de componentes. Esses componentes s√£o organizados dentro de m√≥dulos, a aplica√ß√£o √© modularizada. Os m√≥dulos por sua vez, nos d√£o alguns "poderes", como por exemplo criar determinados componentes que est√£o vis√≠veis apenas dentro do m√≥dulo. Isso traz um maior n√≠vel de encapsulamento. Exemplo: Imagine que voc√™ tem um determinado componente que √© um componente que n√£o pode ser usado fora de determinada situa√ß√£o(ele n√£o pode ser usado no sistema inteiro), ent√£o podemos coloca-lo dentro de um m√≥dulo e ele ficar vis√≠vel apenas dentro daquele m√≥dulo. Dentro do arquivo app.module tem a um atributo chamado bootstrap que tamb√©m serve para inicializar a aplica√ß√£o e aponta para o app.component que √© o que √© criado por padr√£o.

- Arquivo app.component: √â o componente que √© criado por padr√£o, onde a partir dele  toda a √°rvore de componentes ser√° chamada.
____________________________________________________________________________________________________________________________________________________
**O que √© um componente? √â como um peda√ßo da aplica√ß√£o, um trecho de c√≥digo que representa um componente visual da sua tela. Um componente √© composto por um arquivo HTML, CSS e TS. Ou seja,  estrutura(HTML), estilo(CSS), comportamento(TS). Quando um componente √© criado, √© gerado uma tag personalizada, exemplo o componente home.component gera a tag <app-home><app-home>,essa √© a forma para referenciar todo o c√≥digo HTML, CSS  e TS que foi criado. A ideia √© encapsular dentro desse componente as tr√™s tecnologias da WEB.

-Arquivo TS: √â o arquivo de comportamento do componente, a partir dele √© que o Angular ir√° encontrar os arquivos HTML e CSS, pois ele faz uma referencia, ent√£o quando criamos um componentes pelo menos devemos ter o arquivo TS.

**Organiza√ß√£o Usando M√≥dulo: O Angular n√£o organiza a aplica√ß√£o somente em componentes, mas tamb√©m em m√≥dulos, isso significa que todos os componentes ir√£o estar dentro de algum m√≥dulo, seja um √∫nico m√≥dulo para toda a aplica√ß√£o, como numa aplica√ß√£o pequena todos os componentes podem ficar dentro de app.module(m√≥dulo principal criado por padr√£o), como √© o caso deste projeto. Mas podemos organizar nossa aplica√ß√£o em diversos m√≥dulos. Desse modo, quando voc√™ criar um componente dentro do m√≥dulo, voc√™ tem a escolha de dizer se aquele componente ficar√° vis√≠vel para fora do m√≥dulo, ou seja algu√©m de fora do m√≥dulo pode referenciar aquele componente, ou seja ,voc√™ pode dizer que aquele componente vai ficar vis√≠vel  apenas dentro do m√≥dulo.
----------------------------------------------------------------------------------------------------------------------------------------------------
**Anatomia do m√≥dulo: 

- Dentro do arquivo app.module tem 5 atributos: Declarations, Imports, Exports, Providers, Bootstrap.

O que devemos colocar dentro de cada um desses atributos?

-Declarations: Declara todos os componentes que fazem parte daquele m√≥dulo; declarar diretivas que fazem parte daquele m√≥dulo; declarar os pipes que fazem parte daquele m√≥dulo. Neste projeto, ser√° usado para declarar principalmente os componentes que fazem parte daquele m√≥dulo. Quando dizemos que um componente faz pat√™ de um m√≥dulo, n√£o necessariamente ele √© vis√≠vel para fora do m√≥dulo, voc√™ deve colocar esse componente tamb√©m dentro de exports.

-Imports: Serve para importar outros m√≥dulos, ou seja, um m√≥dulo pode depender de outro m√≥dulo, podendo ser um m√≥dulo da pr√≥pria aplica√ß√£o ou um m√≥dulo externo. Podemos importar depend√™ncias e bibliotecas.

-Exports: Serve para declarar componentes, diretivas e pipes que podem ser vis√≠veis para fora do m√≥dulo.

-Providers: Serve para declarar os services.

-Bootstrap: √â onde tem a refer√™ncia do componente principal que ser√° carregado, sendo necess√°rio apenas para 1 √∫nico m√≥dulo, que √© o m√≥dulo inicial da aplica√ß√£o, o app.module. No caso do app.module, n√£o precisamos exportar nada, os outros m√≥dulos √© que v√£o exportar para o app.module utilizar, ou seja o app.module importa os outros m√≥dulos.

----------------------------------------------------------------------------------------------------------------------------------------------------
-OBS: Quando dizemos que um componente faz parte de um m√≥dulo, n√£o necessariamente ele √© vis√≠vel para fora do m√≥dulo. Para tornar um componente vis√≠vel para fora do m√≥dulo, ele deve ser colocado dentro de exports. 
-Quando criamos um componente ele j√° √© registrado dentro de app.module automaticamente, ou seja se estamos trabalhando dentro de um m√≥dulo app.module, s√≥ vai ser poss√≠vel usar componentes que estejam carregados dentro do ap.module.


**DECORATOR: √â um padr√£o de projeto eu tem como objetivo evitar heran√ßa, o inv√©s de trabalhar como heran√ßa, voc√™ trabalha com composi√ß√£o para estender um determinado objeto. Exemplo: @Directive, @NgModule, @Component, etc. O Angular usa para definir que aquele classe exerce algum tipo de papel dentro do framework. Exemplo: Se queremos que uma classe seja um componente, usamos o @Component.
____________________________________________________________________________________________________________________________________________________
**Instalando e criando projeto Angular

-Instalando a cli do Angular. Comando: npm i -g @angular/cli

- Criando um projeto Angular: ng new nome-projeto
- Criando um projeto Angular sem arquivos desnecess√°rios como arquivos de teste: ng new nome-projeto --minimal
- Rodar o projeto Angular: ng serve ou npm start, ambos funcionam.
- Instalando a depend√™ncia do Angular Material: ng add @angular/material
- Criar um componente: ng generate componente nome-do-componente
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Arquivos dentro de um projeto Angular:

- Arquivo angular.json: Possui algumas configura√ß√µes do Angular.
‚úÖ Explica√ß√£o Corrigida e Completa:
Dependendo da vers√£o do Angular (e tamb√©m das configura√ß√µes padr√£o do projeto), ao gerar um novo componente com o Angular CLI (ng generate component), os arquivos de template (HTML) e estilo (CSS/SCSS) podem ser criados dentro do pr√≥prio arquivo .ts ‚Äî o que √© chamado de inline template e inline style. Para alterar esse comportamento padr√£o, voc√™ pode configurar o arquivo angular.json (ou workspace.json, dependendo da estrutura do projeto), adicionando ou modificando as seguintes op√ß√µes:

"@schematics/angular:component": {
  "inlineTemplate": false,
  "inlineStyle": false
}
O que isso faz:
"inlineTemplate": false ‚Üí Garante que o Angular CLI crie um arquivo HTML separado.

"inlineStyle": false ‚Üí Garante que o Angular CLI crie um arquivo CSS/SCSS separado.

Observa√ß√£o importante:
Essa configura√ß√£o define o comportamento padr√£o para quando voc√™ gerar componentes. No entanto, voc√™ ainda pode sobrescrever isso com flags no comando, por exemplo:

ng generate component nome-do-componente --inline-template --inline-style
Ou para desativar inline no comando (mesmo que esteja ativado por padr√£o):

ng generate component nome-do-componente --inline-template=false --inline-style=false 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Arquivo assets: Serve para colocar arquivos est√°ticos, arquivos de imagem e  fontes.
- Arquivo Enviroments: Local onde √© colocado as vari√°veis de ambiente.
_______________________________________________________________________________________________________________________________________________________________________

- Nesta etapa depois de criar o componente de Header,  n√≥s iremos importar dentro do  app.module o MatToolbarModule(barra de ferramentas). Estilizamos o header tamb√©m.
- Criamos e estilizamos tamb√©m o componente footer. Aqui foi usado tamb√©m o MatToolbar.
- Criamos e estilizamos o componente NAV(navega√ß√£o). E iImportei o MatSidenavModule e o MatListModule dentro de app.modulepara usar no componente nav.
_______________________________________________________________________________________________________________________________________________________________________


			# SE√á√ÉO - ELEMENTOS DO ANGULAR - Mini Curso: Componentes, Rotas, Diretivas, Pipes, Observables, Services, Inje√ß√£o de Depend√™ncia.


**COMPONENTE ANGULAR: √â formado em via de regra por 3 partes: HTML, CSS, TS. N√£o necessariamente precisamos ter estilo no componente. Tamb√©m n√£o √© obrigat√≥rio ter o arquivo HTML,  podemos colocar o template dentro do arquivo TS. Existe um escopo("mundo") dentro do componente, ou seja, o componente tem o seu pr√≥prio "mundo" interno, como e fosse uma pequena aplica√ß√£o. Exemplo: Se aplicarmos um estilo CSS em um seletor gen√©rico(link, titulo, etc), esta estiliza√ß√£o ser√° aplicada somente dentro do componente. Existem os arquivos globais, onde s√£o aplicados regras que valem para todos os componentes(index.html, styles.css, etc).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**DIRETIVAS DE ATRIBUTO: Altera apar√™ncia(CSS) e o comportamento de um elemento, componente ou outra diretiva. Exemplo: alguma a√ß√£o dentro de um bot√£o, mudar a cor de algo, etc.

-COMANDO PARA CRIAR UMA DIRETIVA DE ATRIBUTO: ng g d directives/red
-SINTAXE: ng g d nome-da-pasta/nome-da-diretiva

-EXEMPLO DE C√ìDIGO DE UMA DIRETIVA DE ATRIBUTO:

@Directive({
    selector: '[appRed]'
})
export class RedDirective {
    constructor(el: ElementRef) {
        el.nativeElement.style.color = '#e35e6b';
    }
}

- A Diretiva acima, esta pegando o elemento da DOM, pegando atributo style e color(dentro de style), e alterando a cor para vermelho.



-USO DA DIRETIVA NO HTML:
<i class="material-icons v-middle" appRed>  -Aqui a Diretiva altera a cor do √≠cone para vermelho.
    favorite
</i>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**DIRETIVAS ESTRUTURAIS: Altera layout adicionando e removendo elementos da DOM(estrutura da p√°gina/HTML). A diferen√ßa visual entre a diretiva de atributo para a estrutural, √© eu a diretiva estrutural usa asterisco na frente. Exemplo: *ngIf, *ngFor.

-COMANDO PARA CRIAR UMA DIRETIVA DE ESTRUTURAL: ng g d directives/red
-SINTAXE: ng g d nome-da-pasta/nome-da-diretiva

-EXEMPLO DE C√ìDIGO DE UMA DIRETIVA ESTRUTURAL:

<form *ngIf="product" class="product-form">   

</form>

-Aqui ir√° exibir ou n√£o o elemento formul√°rio se o produto estiver definido/setado. Aqui ele  altera a estrutura, porque ele ir√° ou suprimir um determinado elemento ou  mostrar, de acordo com a express√£o colocada no *ngIf. Ou seja, estamos fazendo uma condicional baseada em uma vari√°vel, ele ir√° mostrar o formul√°rio se o produto estiver setado, ou ele simplesmente vai remover o formul√°rio da DOM caso produto n√£o esteja setado. Por isso √© uma diretiva estrutural, pois ir√° mexer na DOM, vai remover um elemento caso a express√£o seja falsa.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

<ul>
    <li *ngFor="let product of products">   
        {{ product.name }}
    </li>
</ul>

- Aqui ele ir√° acrescentar novos elementos. Temos uma UL(lista-n√£o-ordenada) com LI,  e a partir desse LI ele ir√° fazer um la√ßo FOR em cima  dos produtos, se tiver 10 produtos ele vai repetir o LI 10 vezes mostrando os nomes dos produtos. Esta diretiva estrutural ira adicionar novos elementos na DOM de acordo com a lista de produtos.

OBS: O C√ìDIGO PARA CRIAR TANTO UMA DIRETIVA DE ATRIUTO QUANTO UMA DIRETIVA ESTRUTURAL √â O MESMO.
_______________________________________________________________________________________________________________________________________________________________________

**PROPERTY BININDG(BINDING DE ATRIBUTO): √â uma das formas de comunica√ß√£o entre o arquivo TS e o HTML dentro do componente. Binding quer dizer liga√ß√£o,  e assim usando os colchetes associados a um atributo, ele vai fazer a liga√ß√£o e pegar nome que colocamos na propriedade no HTML,  e vai procurar uma vari√°vel com esse nome, e ai sim ele pega o valor da vari√°vel e associa ao dataSource que √© um atributo de tabela. O Material Design usa esse dataSource com mais frequ√™ncia para renderizar tabelas.

-EXEMPLO DE PROPERTY BINDING:

HTML:
<table [dataSource]="products">  
    
</table>

-Aqui o atributo dataSource ir√° no TS buscar a vari√°vel products que √© uma lista(Array) e usar essa vari√°vel para montar a tabela. O dataSource deve estar dentro de colchetes para funcionar.


TS:
@Component({
    selector: 'app-product-read',
    templateUrl: './product-read.compnent.html',
    styleUrl: ['./product-read.component.css']			
})
export class ProductReadComonent
implements OnInit {

    products: Product[];  -Aqui definimos uma  vari√°vel que √© uma lista de produtos no TS,  e ser√° usada pelo dataSorce para construir a tabela no HTML.
}

_______________________________________________________________________________________________________________________________________________________________________

**EVENT BINDING: Usado para fazer liga√ß√£o entre um evento do HTML pra um m√©todo que esta no arquivo TS. Para fazer isso √© usado a sintaxe dos par√™nteses.

-EXEMPLO DE EVENT BINDING:

HTML:
<button mat-raised-button (click)="createProduct()" color="primary"> - Aqui √© a chamada do m√©todo que esta no TS por meio de um evento click, dentro de par√™nteses.
    Salvar
</button>


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    createProduct() {    - Aqui √© o m√©todo criado no TS que ser√° chamado no HTML pelo evento de click.
        //...
    }
}
_______________________________________________________________________________________________________________________________________________________________________

**ONE WAY DATA BINDING(DATA BINDING DE UMA √öNICA DIRE√á√ÉO): One-Way Data Binding (liga√ß√£o de dados unidirecional) significa que os dados v√£o de um √∫nico sentido: do componente(TS) para a view (HTML). √â quando voc√™ exibe dados na tela, mas n√£o os altera diretamente a partir da tela. A view apenas reflete o estado do componente. Imagine que no HTML voc√™ tem um input de nome,  e l√° no arquivo TS voc√™ tem uma vari√°vel chamada nome. Vamos supor que voc√™ coloque na vari√°vel nome o valor Rebeca(nome = "Rebeca"). Por conta do  One-Way Data Binding, ele ir√° aplicar esse nome(Rebeca) para o Input no HTML mostrando o nome Rebeca.
Vamos supor que houvesse uma outra mudan√ßa na vari√°vel do TS de Rebeca para Ana, ele vai mandar uma notifica√ß√£o e atualizar o componente para Ana, porque o valor da vari√°vel no TS mudou.

-EXEMPLO DE ONE WAY DATABINING(EXPLICADO ACIMA):

HTML:
<input [value]="nome">  -Aqui mostra o valor que for colocado na vari√°vel do TS. Tem que usar colchetes pois √© um binding de atributo.


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    nome: string = "Rebeca";  	-Vari√°vel que √© mostrada no input, se mudar o valor, l√° tamb√©m muda.  
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

**TWO WAY DATA BINDING(DATA BINDING DE DUAS DIRE√á√ïES): Two-Way Data Binding significa que os dados v√£o do componente (TS) para a view (HTML) e tamb√©m da view (HTML) de volta para o componente (TS), ou seja, qualquer altera√ß√£o feita na vari√°vel do componente ser√° refletida automaticamente na tela, e qualquer altera√ß√£o feita na tela (como digitar em um input) atualizar√° a vari√°vel no componente. √â muito usado no Angular quando trabalhamos com formul√°rios. Exemplo: Criar usu√°rio, Alterar usu√°rio. Assim tanto se alterarmos no HTML, como no c√≥digo Typescript, os dados v√£o  ficar sincronizados.   

-EXEMPLO DE TWO WAY DATABINING(EXPLCIAOD ACIMA):

HTML:
<input [(ngModel)]="nome"> -Essa √© a sintaxe para se usar o Two Way Data Binding, assim os dados podem ser alterados tanto no HTML quanto no TS.


TS:
@Component({
    selector: 'app-product-create',
    templateUrl: './product-create.compnent.html',
    styleUrl: ['./product-create.component.css']
})
export class ProductCreateComponent implements OnInit {

    nome: string = "Rebeca";  	-Vari√°vel que √© mostrada no input, se mudar o valor, l√° tamb√©m muda e vice versa.  
}

_______________________________________________________________________________________________________________________________________________________________________

**ANGULAR ROUTER: O Angular Router √© o sistema de navega√ß√£o de p√°ginas do Angular.
Ele permite que voc√™ troque de componentes na tela sem recarregar a p√°gina, como se fosse um site de v√°rias p√°ginas ‚Äî mas tudo acontece dentro do Angular.
üß† Por que usar? Imagine um app com v√°rias "telas": Home, Produto, Usu√°rio, voc√™ n√£o quer criar um HTML diferente para cada um, mas sim mudar o conte√∫do dinamicamente. √â isso que o Angular Router faz. Ele funciona com rotas: voc√™ define qual componente deve ser mostrado quando o usu√°rio acessa uma determinada URL.
 
-Por exemplo, quando o usu√°rio clica o menu HOME e a URL HOME √© selecionada, automaticamente o componente HOME vai ser carregado no Router Outlet que √© um componente que faz parte do Angular Router, onde ir√° injetar dentro dele os componentes de acordo com a navega√ß√£o que foi feita. O que vai dizer a navega√ß√£o √© exatamente a URL do componente que foi mapeada, como houve um mapeamento de /home para o componente Home, automaticamente quando voc√™ navega para ele, ele vai colocar o componente no local especificado que voc√™ disse. Se o usu√°rio for l√° e navegar para /produto, automaticamente ele vai trocar os componentes e vai carregar nesse mesmo local que voc√™ previamente definiu com o componente do Router(Router-Outlet) ele vai substituir o produto. Da mesma forma se o usu√°rio for l√° e navegar para /usu√°rio, seja clicando o menu ou mesmo colocando direto na URL, ele vai substituir o componente produto pelo componente usu√°rio. Ent√£o sempre que voc√™ for navegando na sua aplica√ß√£o, basicamente vai ter um mapeamento entre a rota e o componente, e ai tendo um mapeamento entre a rota e o componente ele coloca dentro desse elemento no Router Outlet o componente selecionado a partir da rota.

-EXEMPLO DE ROUTER:

HTML:
<a routerLink="/products"> -Link da URL da rota do componente onde o usu√°rio poder√° acessar na aplica√ß√£o.
  Produtos
</a>


TS:
const routes: Routes = [{
  path: "products",   			- Aqui √© definido a rota para o componente products. Path √© o caminho.
  componente: ProductCrudComponent 
}, {
  path: "products/create",
  component: ProductCreateComponent
}]; 


ROUTER OUTLET:
<mat-sidenav-content>
  <router-outlet></router-outlet> -Aqui dentro de <router-outlet></router-outlet> √© onde as rotas ser√£o carregadas.
</mat-sidenav-content>
_______________________________________________________________________________________________________________________________________________________________________

**PIPES: S√£o processamentos que voc√™ faz em cima de vari√°veis. Ou seja, voc√™ pode usar pipes para fazer a formata√ß√£o de dados. Por exemplo, digamos que  eventualmente o formato que voc√™ recebeu de um banco de dados, n√£o √© o formato que voc√™ quer exibir, e para isso voc√™ ode usar um pipe para formata√ß√£o de um dado. Por exemplo, eu recebi um valor num√©rico e eu quero formatar esse valor como um valor de moeda, em real colocando o s√≠mbolo de real e quero colocar duas casas decimais. Ent√£o voc√™ pode passar esse valor e colocando um pipe | (barra reta), onde ter√° um m√©todo que ser√° chamado e ir√° processar esse valor para transformar esse dado o formato que voc√™ quer. 

-EXEMPLO DE PIPE:
<p>
    O vencimento √© 
    {{ produto.vencimento | date }}
</p>
----------------------------------------------------------------------------------------------------------------------------------------------------

-EXEMPLO DE PIPE COM PAR√ÇMETRO:
<td mat-cell *matCellDef="let product">
    {{ product.price | currency: 'BRL' }}
</td>

 -Aqui estamos exibindo a propriedade price do objeto product, utilizando o pipe currency para formatar o valor como uma moeda.
O par√¢metro 'BRL' indica que a moeda usada deve ser o Real brasileiro (R$).
Ou seja, o valor ser√° exibido no formato de moeda brasileira, como por exemplo: R$ 1.000,00.

üìå Observa√ß√µes extras (se quiser aprofundar):
Se voc√™ n√£o passar par√¢metro, o Angular usa a moeda padr√£o do sistema.

√â poss√≠vel tamb√©m passar mais par√¢metros para personalizar, como o n√∫mero de casas decimais.

Exemplo com mais op√ß√µes:

{{ product.price | currency:'BRL':'symbol':'1.2-2' }}
Mostra o s√≠mbolo da moeda e sempre com duas casas decimais (ex: R$ 1.000,00).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

-EXEMPLO DE UMA CADEIA DE PROCESSAMENTO/CADEIA DE PIPES- Tamb√©m chamada de CHAINING:
<p>
    O vencimento √© 
    {{ produto.vencimento | date: 'fullDate' | uppercase }}
</p>

-Essa cadeia de pipes formata a data de vencimento (produto.vencimento) para o formato completo (fullDate) e depois transforma o texto todo em letras mai√∫sculas (uppercase).
_______________________________________________________________________________________________________________________________________________________________________
**PROGRAMA√á√ÉO REATIVA(REACTIVEX): O Angular usa esse framework ReactiveX que trabalha com conceitos de programa√ß√£o reativa. Programa√ß√£o reativa tem o conceito de o c√≥digo s√≥ ser√° chamado de forma reativa, ou seja, precisa acontecer alguma coisa externa, no caso um evento para dai quando acontecer isso o c√≥digo ser executado.

-IMPORTA√á√ÉO DO OBSERVABLE NO ANGULAR: import { Observable } from "rxjs";

*O PADR√ÉO OBSERVER: √â o padr√£o de projeto mais utilizado na web. Tudo come√ßa a partir do padr√£o Observer. √â um padr√£o orientado Evento.



-Subject: √â quem tem a capacidade de monitorar e detectar quando um evento acontece.
-Observer: S√£o os c√≥digos que est√£o interessados num determinado evento.

*  O que acontece, se voc√™ tirar a figura do Subject, os observables(quem esta interessado em monitorar os eventos) precisam ficar monitorando os eventos, mas se voc√™ tiver algu√©m que vai ser capaz de monitorar os eventos, voc√™ pode delegar para esse Subject. Exemplo: "Monitore o evento tal, e  quando acontecer o evento me notifique" ou seja, me avise que o evento aconteceu. Por isso os observadores precisam se registrar no Subject dizendo que ele √© interessado no evento, ou seja, para o padr√£o de projeto Observer existir, antes precisa haver um explicito desejo dizer "Eu estou interessado em receber notifica√ß√µes de um determinado evento", ou seja, h√° um registro do  Observador que √© quem est√° interessado  no Subject.
Depois que h√° esse registro o Subject vai detectar o Evento. O Evento aconteceu e ele √© capaz de detectar e perceber que o determinado evento aconteceu, ou seja, uma vez que  Subject detectando que o Evento aconteceu e ele tem dentro dele uma lista de todos os Observadores(Observers) que est√£o interessados de ser notificados, ele vai notificar todos s Observadores dizendo: "O evento que voc√™s estavam esperando aconteceu". Quando o Subject notifica, √© executado uma fun√ß√£o dentro de cada Observador e ai ele vai fazer aquilo que √© necess√°rio de acordo com o evento que foi gerado.
EXEMPLO: Imagine que voc√™ tem um evento de compra, e voc√™ tem um Observador que √© para enviar um email para o usu√°rio. Voc√™ tem outro Observador que √© para dar baixa no estoque, voc√™ tem outro Observador que vai mandar uma mensagem para um outro sistema que via separar mercadoria. E ai aconteceu o evento da venda, algu√©m foi l√° e comprou, e ai o Subject que √© quem est√° monitorando esse evento da compra vai notificar para o Observador de email: "Olha aconteceu uma compra". Ai o Observador de email vai pegar aquela compra e enviar um email pro usu√°rio: "Sua compra foi realizada com sucesso, estamos processando a sua compra e dentro de algumas horas iremos mandar novas notifica√ß√µes com o progresso no seu email". Ai esse evento foi passado para um outro Observador que quer dar uma baixa no estoque, ele vai l√° e manda essa compra, e ele vai ver todos os produtos que est√£o dentro da compra,  e subtrai 1 do estoque. Ai o pr√≥ximo Observador recebe o evento da compra e ele manda para um sistema de separa√ß√£o do produtos que o produto "tal", "tal" e "tal" podem ser separados. Ent√£o percebe-se que o Subject √© quem detecta o evento, mas ele funciona como um intermedi√°rio, l√™ e entende que o evento aconteceu e notifica os interessados.

-EXEMPLO DE ANALOGIA DE OBSERVABLE E SUBJECT-ANIVERS√ÅRIO SURPRESA: Existem 2 personagens nesta hist√≥ria: A namorada que representa o Observer e o Porteiro que representa o Subject. H√° tamb√©m o Evento que √© a chegada do aniversariante. Essa hist√≥ria ter√° 2 possibilidades.

-CEN√ÅRIO 1-SEM  OBSERVER: A namorada n√£o ir√° usar o padr√£o Observer e ela vai ficar de forma proativa na janela olhando os carros chegarem, quando chegar o carro amarelo do namorado, ela vai para dentro da sala e diz "Pessoal ele acabou de chegar, vamos apagaras luzes e ficar em sil√™ncio para a gente fazer a surpresa". Neste primeiro cen√°rio sem um Observer, quem estava interessada no evento(que era namorada), ela ficou parada sem curtir mais a festa olhando na janela at√© que o evento acontecesse para dai ela ser respons√°vel por todo o processo de detectar o evento e avisar todos os convidados.  Neste caso como ela teve uma postura proativa, ficou muito  ruim para ela, porque ela ficou totalmente ocupada em detectar o evento e da√≠ avisar os convidados.

-CEN√ÅRIO 2-COM OBSERVER: A namorada delegou a tarefa de ficar observando para o porteiro, aqui temos o uso do padr√£o Observer, porque o Porteiro √© o Subject. Como ele esta na portaria ele tem a capacidade de detectar o Evento de uma forma muito mais f√°cil, at√© porque o Namorado vai ter que passar pelo pr√©dio ou pela portaria, ent√£o ele tem a posi√ß√£o privilegiada pra detectar o Evento. Ent√£o o eu foi que a Namorada fez? Lembra que a ente disse que precisava fazer  um registro, ou seja o Observer que √© o interessado, ele precisa se registrar om o Subject para dizer "Eu estou interessado em receber o Evento", para a Namorada avisar o Porteiro de que ele precisa ficar observando o Evento, ela precisou interfonar e pedir: "Voc√™ tem como observar a chegada do carro amarelo?", ai o Porteiro disse: "Ok, deixa comigo que assim eu o Evento acontecer eu notifico voc√™s de volta". Ou seja, esse notificar de volta, √© o Porteiro depois de olhar e perceber que o Evento aconteceu e detectar o Evento, ele vai interfonar de volta dizendo que o Evento aconteceu, s√≥ ent√£o a Observadora que √© a Namorada que √© interessada pelo Evento ela vai fazer todo o procedimento para que o aniversario surpresa acontecer.
Ent√£o 1¬∫ A Namorada precisou ligar pro Porteiro se registrando dizendo "Olha estou interessada no Evento X", o Porteiro deu um OK dizendo: "Pode deixar comigo, quando acontecer o Evento eu notifico de volta", da√≠ o conceito de CALLBACK(chamada de volta) para notificar que o Evento aconteceu. Ent√£o ele liga de volta dizendo: "O Evento aconteceu", ai a Namorada  que j√° estava curtindo a festa e que n√£o estava mais preocupada em ficar olhando pela janela, foi l√° recebeu a notifica√ß√£o do Porteiro e ai sim ela fez todo o trabalho de prosseguir com os preparativos para a surpresa.
Ent√£o deixa bem claro que trabalhar com o padr√£o Observer deixa o Observador que √© o interessado livre para fazer outras coisas e nesse cen√°rio houve uma chamada reativa, ela n√£o estava querendo de forma proativa ficar na janela, ela quis ficar de forma reativa, ela s√≥ vai fazer as coisas quando um determinado Evento acontecer. Por isso que o padr√£o Observer √© um padr√£o orientado a Evento.
----------------------------------------------------------------------------------------------------------------------------------------------------

*ENTENDENDO OBSERVABLES: Do ponto de vista do Javascript puro a gente come√ßa a trabalhar com esse conceito de reatividade a partir de que voc√™ tem a possibilidade de passar uma fun√ß√£o como par√¢metro para outra fun√ß√£o, e essas fun√ß√µes s√£o chamadas tamb√©m de CALLBACKS. Por exemplo: Voc√™ passa uma fun√ß√£o para outra fun√ß√£o como par√¢metro para outra fun√ß√£o dizendo: "Eu quero que voc√™ invoque essa fun√ß√£o que eu estou passando como par√¢metro, quando a resposta a requisi√ß√£o chegar". E ai ele vai l√° e chama a CALLBACK. Um dos problemas da CALLBACK √© quando voc√™ tem uma logica mais complexa e voc√™ vai acabar caindo num cen√°rio que voc√™ precisa passar uma CALLBACK dentro de outra CALLBACK(CALLBACK HELL), uma  fun√ß√£o dentro da outra, tornando assim o c√≥digo de dif√≠cil leitura e tamb√©m de dif√≠cil manuten√ß√£o. Quanto mais outras CALLBACKS, outras logicas fossem adicionadas ficava ainda mais complicados a c√≥digo.

-A partir do ECMA Script 2015 surgiu um conceito de Promises onde tamb√©m s√£o usados os CALLBACKS, mas na Promisse tem a capacidade de encadear as varias chamadas, voc√™ consegue compor melhor varias chamadas de Promisses,  sem ter essa quest√£o desse aninhamento que era causado pelo CALLBACK. Quais os problema da Promisse? A Promisse voc√™ usa apenas uma √∫nica vez. Se voc√™ executou um determinado c√≥digo usando Promisse, depois que termina voc√™ n√£o consegue reutilizar essa Promisse. E como evolu√ß√£o da Promisse, que voc√™ consegue ter os mesmos benef√≠cios de ser f√°cil a composi√ß√£o, voc√™ consegue chamar varias fun√ß√µes encadeadas numa forma simples, s√≥ que com outros benef√≠cios, voc√™ tem o Observable.

-Os Observables que est√£o dentro do RXJS que o Angular usa como depend√™ncia, possuem algumas vantagens por exemplo: 
1- Um Observable diferente da Promisse voc√™ consegue reusar ele.

2- Consegue lidar com um STREAM DE DADOS, vamos supor que voc√™ precisa ficar monitorando uma determinada vota√ß√£o presidencial, e voc√™ pode criar um Observable para ficar de tempo em tempos consumindo essa informa√ß√£o do servidor, ou seja, com um √∫nico Observable voc√™ consegue ficar recebendo uma STREAM DE DADOS. Exemplo: "Foram apurados 20% da urna onde um candidato esta com 50% e outro esta com 50%". Daqui a pouco chega mais informa√ß√µes dizendo "Foram apuradas 40% das urnas e agora um candidato esta com 60%e o outro esta com 40%", depois chegam mais dados. E com 1 √∫nico Observable voce fica recebendo esse STREM DE DADOS, ou seja, um conjunto de dados em sequencia, sem necessariamente ficar criando novos objetos porque voce consegue reusar.

3- Operadores: As Promises tamb√©m tem um outro "poder" que s√£o os Operadores, que s√£o fun√ß√µes que podem ser usadas juntamente com os Observables. Por exemplo no caso da Promisse voc√™ tem basicamente o m√©todo then. No caso dos Obsevables voc√™ tem outros m√©todos como map. Voc√™ consegue fazer filtros que s√£o tipo de fun√ß√µes(Operadores) que voc√™ consegue trabalhar com os seus dados. Por exemplo:  Eu acabei de receber uma lista de produtos do meu backend, voc√™ te como ficar trabalhando com esses dados a partir dos Observables de uma maneira muito interessante. Ent√£o tem uma serie de fun√ß√µes que ajudam a processar os dados. Em outras palavras por tr√°s do Observable ele vai encapsular essa quest√£o do padr√£o Observer. O padr√£o Observer √© a base da programa√ß√£o reativa, ou seja s√≥ tem programa√ß√£o reativa a partir do padr√£o Observer. Quando o evento acontece ai sim √© que o c√≥digo vai de forma reativa agir por conta que um determinado evento que aconteceu.

- Quando voc√™ trabalha com Observable, Promisse ou CALLBACK, via de regra voc√™ esta trabalhando com c√≥digo ass√≠ncrono, ou seja, n√£o h√° um resposta imediata na chamada do seu c√≥digo. Um exemplo claro de chamada ass√≠ncrona, √© quando voc√™ vai fazer uma chamada pro bakend da sua aplica√ß√£o.

EXEMPLO:

criarNoBackend(produto: Produto): Observable<Produto> {
  return this.http.post<Produto>(ths.url,produto);
}

-Esse m√©todo recebe um produto como par√¢metro e faz uma chamada do tipo post para cadastrar esse produto no backend. Foi chamado o m√≥dulo http do Angular que serve para trabalhar com as requisi√ß√µes HTTP. Entretanto o backend da nossa aplica√ß√£o demora as vezes alguns segundos para responder, ent√£o esse m√©todo n√£o ira responder na hora que voc√™ chamou, ele via responder depois de algum tempo no futuro, por isso esse m√©todo retorna um Observable, e esse Observable que ser√° retornado a partir desse m√©todo, podemos passar para ele registrar um Observador(exatamente o que esta acontecendo no c√≥digo abaixo no subscribe). Voc√™ pode registrar um Observador:

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

criarProduto(): void {
  this.criarNoBackend(this.produto).subscribe (() => {
    this.exibirMensagem("Salvo com sucesso!");
})
}

- Neste m√©todo eu chamei o criarNoBackend, passei o produto e como resposta dessa chamada eu recebo um Observable, ou seja,  na hora que eu chamo ele j√° retorna um Observable, s√≥ que a resposta do servidor anda n√£o chegou, por isso que eu chamo o m√©todo subscribe e ai eu passo uma fun√ß√£o para ser chamada quando a resposta do servidor chegar.

-Neste m√©todo esta sendo registrado um Observador, que √© a fun√ß√£o Arrow que esta sendo passada como par√¢metro para o subscribe. Ou seja, o subcribe √© o m√©todo de registro. Neste caso o Observable √© o meu Subject. Ou seja, o Observable tem a capacidade de detectar que um determinado evento aconteceu, que √© o evento da resposta do meu servidor(backend) para minha requisi√ß√£o post que foi feita, e quando essa resposta chegar  m√©todo que eu passei para o subscribe ser√° chamado e ai sim eu posso exibir uma mensagem por exemplo, de que o usu√°rio foi salvo, ou chamar a navega√ß√£o para ir para uma outra tela, ou seja, eu posso fazer qualquer coisa que eu queira em resposta da minha chamada ao backend.
_______________________________________________________________________________________________________________________________________________________________________


**SERVICES: S√£o classes que tem como principal objetivo organizar e compartilhar m√©todos e dados entre componentes. √â poss√≠vel tamb√©m utilizar Services dentro de Diretivas. A ideia √© voc√™ separar responsabilidades.
-Tudo aquilo que diz respeito a responsabilidade de mostrar algo visual na tela diz respeito ao componente. Mas sempre que voc√™ tem regras que n√£o tem respeito diretamente com a parte visual, ou voc√™ quer encapsular o acesso a sua API(o backend da aplica√ß√£o), o ideal √© voc√™ separar as responsabilidades e colocar algumas responsabilidades no Service, porque diz respeito a parte n√£o visual que n√£o tem diretamente uma rela√ß√£o com aquilo que esta sendo exibido na tela, voc√™ tamb√©m pode colocar toda a responsabilidade de acessar o backend da sua aplica√ß√£o. O Angular n√£o te for√ßa a criar os Services, voc√™ pode criar Service com essa ideia tanto de separar responsabilidades, como tamb√©m viabilizar comunica√ß√£o entre componentes. Por exemplo: Eu preciso de uma determinada informa√ß√£o e essa informa√ß√£o precisa ser compartilhada entre o Componente A e o Componente B, onde os componentes n√£o est√£o pr√≥ximos onde n√£o h√° como passar essa informa√ß√£o de um componente para outro, par isso podemos usar Services como uma forma de compartilhar dados e m√©todos entre componentes.

*MOTIVA√á√ÉO PARA O SERVICE: Imagine que temos o Componente 1 que possui seu HTML, CSS,TS. E dentro do TS nos temos um certo conjunto de l√≥gica. E tamb√©m temos o Componente 2 que tamb√©m tem  seu HTML, CSS TS e dentro do TS tamb√©m possui o seu conjunto de l√≥gica. Usamos o Service para colocar as l√≥gicas que n√£o est√£o relacionadas com a parte visual dos componentes e que n√£o s√£o da responsabilidade dos componentes. Nem toda aplica√ß√£o ter√° apenas 1 √∫nico Service com varias logicas dentro, tudo ira depender de voc√™ ter responsabilidades coerentes dentro de um Service. N√£o necessariamente voc√™ precisa ter um √∫nico m√©todo dentro de cada Service, mas voc√™ vai ter um Service respons√°vel por um conjunto coerente de responsabilidades.
-Por exemplo: um cadastro, onde eu vou criar um produto, alterar um produto, excluir um produto, consultar um produto por ID. Voc√™ pode colchoar isso tudo dentro de um Service s√≥, mas voc√™ n√£o vai colocar outras funcionalidades que n√£o dizem respeito ao produtos, como cadastrar um cliente, alterar um cliente ou mexer num fornecedor dentro de um Service que esta focado para trabalhar nas coisas relacionadas aos produtos. Ent√£o √© importante ter esse cuidado de ter Services que tem logicas que tem um coer√™ncia de estar juntas caso n√£o haja essa coer√™ncia voc√™ cria mais de um Service. Para usar o Service dentro de um Componente precisamos usar Inje√ß√£o de Depend√™ncia.

-CRIAR UM SERVICE: ng g s services/product 
Sintaxe: ng g s nome da pasta/nome do service



-EXEMPLO DE UMA CLASSE QUE REPRESENTA UM SERVICE: Aqui o decorator @Injectable significa que essa classe vai ser detectada pelo Angular e ela vai ser poss√≠vel de ser injetada em outras classes.

 O provideIn: "root" significa que existe um injetor(Injector) e esse injetor √© o injetor raiz da nossa aplica√ß√£o. Basicamente s√≥ existe  1 injetor raiz da minha aplica√ß√£o e uma vez definido que o meu produtoService vai ser provido pelo "root", significa que eu vou ter apenas uma √∫nica inst√¢ncia do ProdutoService em toda a minha aplica√ß√£o, ou seja, sempre que eu injetar o meu produtoService dentro de um Componente, Diretiva o Angular vai me devolver a mesma inst√¢ncia.
 

@Injectable({
  provideIn: "root",
})
export class ProductService {
  //...
}


-Quando usamos o comando para criar um Service: ng g s nome da pasta/nome do servisse. No exemplo acima , o nome do arquivo ficaria product.service.ts e o nome da classe ficou ProductService. No Angular existe todo um Guide Line relativo  nomenclatura dos Componentes, Services, Diretivas, ent√£o precisamos ficar atentos o m√°ximo poss√≠vel as Guides Lines porque isso ira nos ajudar a manter o nosso projeto, como se outros desenvolvedores vierem para o projeto eles ir√£o estar muito mais familiarizados porque √© uma forma padr√£o de se usar nomenclatura dentro do Angular.


-OBS: Existe um padr√£o de projeto do Design Pattern chamado Sigleton, que consiste em criar apenas uma √∫nica instancia de uma classe, as vezes criando um construtor privado dependendo da linguagem, ou as vezes criando um m√©todo para devolver essa inst√¢ncia. Como o Angular ele vai  gerenciar a cria√ß√£o do Service e vai ser respons√°vel por gerenciar a cria√ß√£o dos componentes, porque voc√™ n√£o instancia uma classe produtoService, da mesma forma que voc√™ n√£o vai instanciar uma classe correspondente a um componente, voc√™ n√£o vai instanciar um componente. Quem vai fazer todo esse trabalho de instanciar essas classes gerenciadas como: Componente, Diretiva, Service √© o Angular. Ent√£o como o Angular √© respons√°vel por gerenciar a cria√ß√£o desses objetos, ele tamb√©m vai ser respons√°vel por Injetar Depend√™ncia de um objeto no outro, como tamb√©m √© respons√°vel por garantir que uma determinada instancia sempre ser√° devolvida quando voc√™ pedir. Imagine que voc√™ tem um Service e esse Service tem um contador dentro dele, se voc√™ vai l√° e aumenta esse contador para 10 em um determinado Componente A,  quando voc√™ injetar esse Service no Componente B, 
o contador vale 10. E se l√° no Componente B  voc√™ aumentar esse contador para 30, quando voc√™ injetar esse Service novamente dentro do Componente A, o contador agora vale 30. Se voc√™ aumentar esse contador novamente para 130 e voc√™ vai injetar esse Service no Componente C, o contador vale 130, porque estamos sempre trabalhando com a mesma inst√¢ncia do Service uma vez que voc√™ usa o provideIn: "root".
_______________________________________________________________________________________________________________________________________________________________________

**INJE√áAO DE DEPEND√äNCIA: √â um padr√£o no qual a classe recebe as depend√™ncias de uma fonte externa ao inv√©s de criar por conta pr√≥pria.

-Num cen√°rio padr√£o quando uma Classe A precisa de uma Classe B, ou seja, a Classe A vai precisar da Clase B, ent√£o a Classe A vai criar a Classe B. √â muito natural acontecer isso, mas na Inje√ß√£o de Depend√™ncia ha uma invers√£o dessa logica, ou seja, √© um padr√£o onde a classe recebe as depend√™ncias a partir de uma fonte externa ao inv√©s de criar por conta pr√≥pria. Ou seja, a Classe A precisa da Classe B, ao inv√©s da Classe A criar por conta pr√≥pria uma inst√¢ncia da Classe B, a Classe A vai receber a Classe B a partir do construtor ou a partir de algum outro mecanismo como √© o caso da Inje√ß√£o de Depend√™ncia.
Dependendo da linguagem, framework que voc√™ vai usar a forma  de implementar a Inje√ß√£o de Depend√™ncia √© diferente.

-EXEMPLO  DE UM CEN√ÅRIO SEM INJE√á√ÉO DE DEPEND√äNCIA: A classe Carro depende da Classe Motor

CLASSE CARRO   	  ===>                CLASSE MOTOR

class Carro {                          class Motor {}
  motor: Motor

 construtor() {
  this.motor = new Motor()
 }
}

-Neste cen√°rio a Classe Carro depend√™ncia da Classe Motor. Ent√£o nada mais natural dentro do construtor voc√™ instanciar o Motor a parir da linha : ths.motor = new Motor(), ou seja, voc√™ acabou de instanciar um objeto Motor e atribuiu a vari√°vel dentro da Classe Carro, e tal forma de que quando Carro for instanciado o Carro ter√° automaticamente um Motor. Mas quem foi respons√°vel por instanciar o Motor ? Foi a pr√≥pria Classe Carro, ou seja, ai n√£o houve Inje√ß√£o de Depend√™ncia, porque a Classe Carro foi respons√°vel por criar uma instancia da Classe Motor.


- Se por algum motivo a Classe Motor tiver uma altera√ß√£o, por exemplo, onde para criar um objeto Motor eu preciso dizer qual cilindrada aquele Motor tem. S√≥ que uma vez que eu mexi na classe Motor, na Classe Carro gerou um impacto, pois como Carro cria o Motor agora voc√™ obrigatoriamente precisa passar uma cilindrada como par√¢metro para a constru√ß√£o do Motor. Isso faz com que sempre que voc√™ mexa na Classe Motor, voc√™ tamb√©m tenha que alterar a Classe Carro, gerando uma fragilidade, ou seja, a Classe Carro esta muito dependente da Classe Motor.

CLASSE CARRO:
class Carro {
  motor: Motor

  construtor() {
    this.motor = new Motor() --Gera erro aqui.
  }
}


CLASSE MOTOR ALTERADA: Gera um erro na Classe Carro, obrigando que a  Classe  Carro tamb√©m seja alterada.
class Motor {
 cilindrada: number

  construtor(cilindrada: number) {
  this.cilindrada
 }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-EXEMPLO  DE UM CEN√ÅRIO COM INJE√á√ÉO DE DEPEND√äNCIA:

-Uma forma de resolver isso seria passar Motor como par√¢metro para o Carro. Fazendo isso, significa que algu√©m externo, imagina que voc√™ tem uma classe chamada Fabrica e na hora de voc√™ criar o Carro voc√™ cria o Motor, sabe exatamente o que precisa passar para o Motor e ai sim voc√™ passa o Motor constru√≠do para dentro do Carro. Ou seja, uma fonte externa passou a depend√™ncia para dentro do Carro. E ai voc√™ vai ter frameworks que v√£o te ajudar no processo de Injetar Depend√™ncia.

  
class Carro {
  motor: Motor

  construtor (motor: Motor) {  -Passando o Motor como par√¢metro
    this.motor = motor
  }
}

class Motor {
 cilindrada: number

  construtor(cilindrada: number) {
  this.cilindrada
 }
}



-Principalmente no caso do Angular se a gente substituir Carro por Componente e substituir Motor por Service. Quem √© respons√°vel  por criar o Carro, ou seja o Componente , e quem √© respons√°vel por criar  Service √© o Angular, ent√£o ele ser√° capaz de prover essas depend√™ncias pra gente a partir da Inje√ß√£o de Depend√™ncia.

-Dentro do Framework Angular tem um m√≥dulo de Inje√ß√£o de Depend√™ncia, ou seja, h√° um framework dentro do outro. Ent√£o quando voc√™ cria uma classe ProductService e diz que essa classe  √© @Injectable, voc√™ esta dizendo em outras palavras que essa classe ode ser injetada  e ao mesmo tempo que voc√™ coloca um @Injectable voc√™ esta dizendo pro Angular que ele deve considerar essa classe, ele  deve instanciar essa classe para voc√™. 
Ent√£o o Angular vai instanciar essa classe criando uma instancia e ProductService. Num cen√°rio comum eu tenho uma √∫nica instancia, isso n√£o significa que eu n√£o possa ter mais. Mas no cen√°rio da nossa aplica√ß√£o usando provideIn: "root", ele vai ter apenas uma instancia dessa classe para toda a aplica√ß√£o(ProductService). Sempre que injetarmos ProductService ele vai pegar essa √∫nica instancia.
Depois que o Angular instanciar o ProductService, agora ele vai precisar instanciar  o ProductCreateComponent(Componente de cria√ß√£o de produto) porque ele foi referenciado em algum ponto da sua aplica√ß√£o. Quando Angular for gerar uma instancia desse Componente ele ira criar um Componente e vai passar como par√¢metro e injetar o ProductService no Componente.

Ent√£o nos temos o framework(Angular) quando ele instancia ele cria  o ProductService, e quando ele for instancia o Componente(ProductCreateComponent) ele passa o ProductService que √© injetado no Componente. N√£o necessariamente voc√™ vai ter apenas 1 √∫nica instancia do componente, sempre que voc√™ referenciar o componente a partir da sua tag ele vai criar uma nova instancia daquele componente, para cada tag voc√™ vai ter uma instancia. Portanto quem vai ser respons√°vel por criar essas instancias √© o Angular.

Falando a respeito do provideIn: "root". O "root" √© um apelido(alias) para o AppModule, chamado de root injector. Associado ao AppModule, que √© o modulo inicial da aplica√ß√£o, o root injector √© respons√°vel pela inje√ß√£o de depend√™ncia e ele esta associado ao AppModule. Quando voc√™ diz que o seu provideIn vai ser o "root", voc√™ esta dizendo em outras palavras que o provideIn vai ser o AppModule. Como s√≥ tem 1 AppModule dentro da sua aplica√ß√£o, sempre que voc√™ criar alguma coisa que usa @Injectable  provideIn: "root", significa que esse Service por exemplo vai ter apenas uma √∫nica instancia em toda a sua aplica√ß√£o.


*SINGLETON: Services s√£o sigletons(apenas uma √∫nica inst√¢ncia) dentro do escopo de um injector.

-INJECTOR: Temos 2 grupos de injetores: 

- ModuleInjector(injetor de m√≥dulo): Sempre que usamos @ngMoudle e dentro do m√≥dulo voc√™ define os providers e voc√™ referencia um determinado Service, voc√™ esta usando um injetor de modulo. Significa que dentro do escopo do seu modulo voc√™ vai ter apenas uma √∫nica instancia daquele servi√ßo. Quando voc√™ usa um @Injectable da mesma forma voc√™ passar tanto o root que ai voc√™ tem a √∫nica instancia pra toda a sua aplica√ß√£o como voc√™ ode usar dentro do Injectable o provideIn apontando para um modulo, ou seja, voe tamb√©m esta usando um ModuleInjector, ou seja aquele Service vai ter apenas 1 √∫nica instancia dentro do escopo do modulo ou dentro do escopo  a sua aplica√ß√£o se voc√™ estiver usado o injetor root, o raiz. Quando usamos root, e o root aponta para o AppModule estamos usando o ModuleInjector.

 - ElementInjector(injetor de elemento):Quando voc√™ usa os providers dentro de Diretiva(@Directive) ou um Componente(@Component), voc√™ pode definir a partir da propriedade providers que voc√™ pode definir alguns servi√ßos que voc√™ quer colocar dentro do seu componente, e ai sim voc√™ esta dizendo que voc√™ quer ter uma instancia pr√≥pria dentro daquele componente  de um determinado Service. Ent√£o ao inv√©s de voc√™ usar a instancia √∫nica que esta sendo compartilhada na sua aplica√ß√£o inteira, voc√™ vai usar dentro de um determinado componente o Service, voc√™ pode querer uma instancia dedicada, ou seja, criar uma nova instancia para ser injetada naquele componente. Ai voc√™ usa dentro de @Componentou dentro de @Directive, voc√™ usa os providers para colocar quais s√£o os servi√ßos eu voc√™ quer eu sejam injetados novas instancias.

-OBS: No lugar de root voc√™ pode colocar a referencia para um modulo. Vamos supor eu voc√™ tenha um m√≥dulo da sua aplica√ß√£o de autentica√ß√£o. Voc√™ criou um modulo chamado authModule e voc√™ quer dentro desse modulo de autentica√ß√£o ter um determinado servi√ßo dentro daquele escopo, ent√£o voc√™ pode dizer que o provideIn √© o authModule, mas sem as aspas: @Injectable provideIn: authModule. As aspas em root s√≥ serve para ele ter um alias para o AppModule. Voc√™ vai ter que de fato fazer um import do modulo para dai voc√™ referenciar ao modulo aqui dentro do provideIn. Ent√£o no lugar do root voc√™ pode ter qualquer outro modulo da sua aplica√ß√£o.

-Por via de regra na nossa aplica√ß√£o a gente vai estar sempre usando o ModuleInjector, especificamente usando a partir da nota√ß√£o @Injectable e o provieIn a gente vai usar o root, ou seja, nos vamos ter apenas uma √∫nica instancia em toda a nossa aplica√ß√£o.

Mas quando voc√™ tem aplica√ß√µes mais complexas com v√°rios m√≥dulos,  √© interessante voc√™ ter tamb√©m a capacidade de definir um escopo de um Service um pouco mais restrito. Ent√£o voc√™ pode  usar diferentes estrat√©gias para que voc√™ possa definir o escopo do seu Service. Existem mais informa√ß√µes na documenta√ß√£o do Angular: https://angular.io/guide/hierarchical-dependency-injection.
_______________________________________________________________________________________________________________________________________________________________________


**Foi criado uma pasta chamada views e dentro foi colocada o componente home.
-Para organizar melhor as pastas do projeto, quando eu tenho uma tela inteira eu vou colocar dentro da pasta view, como √© o caso do home.component. Dentro da pasta componentes tudo aquilo que for trechos de componentes reutilizados que podem ser reutilizados em mais de 1 tela, como √© o caso do header.component,nav.component, footer.component,etc. Que s√£o apenas partes da tela.

‚úÖ O que o routerLink faz?
O atributo routerLink √© uma diretiva do Angular Router. Ele funciona como o href de um <a>, mas de forma mais inteligente e integrada ao sistema de rotas do Angular.


_______________________________________________________________________________________________________________________________________________________________________


üî∑ O que √© <mat-sidenav-container>?
O <mat-sidenav-container> √© um componente do Angular Material que cria uma estrutura de layout com:

Um menu lateral (<mat-sidenav>)

Um conte√∫do principal (<mat-sidenav-content>)

Esse layout √© muito comum em sistemas, tipo painel administrativo ou sistemas internos.

 Estrutura b√°sica:

<mat-sidenav-container>
  <mat-sidenav> MENU </mat-sidenav>
  <mat-sidenav-content> CONTE√öDO PRINCIPAL </mat-sidenav-content>
</mat-sidenav-container>
_______________________________________________________________________________________________________________________________________________________________________

‚úÖ O que √© <mat-sidenav-content>?
Esse √© o local principal onde o conte√∫do da sua aplica√ß√£o ser√° exibido. √â o "corpo" da p√°gina.

Ent√£o tudo que muda conforme a rota (p√°gina atual) ‚Äî como Produtos, In√≠cio, etc ‚Äî deve ser renderizado dentro do <mat-sidenav-content>.

ü§î Por que o <router-outlet> est√° aqui dentro?
O <router-outlet> √© onde o Angular renderiza o componente da rota atual. Ele precisa estar dentro do local onde voc√™ quer que o conte√∫do mude quando o usu√°rio clicar nos links do menu.

Se voc√™ colocasse o <router-outlet> l√° no app.component.html, fora do <mat-sidenav-content>, o conte√∫do renderizado poderia aparecer fora do layout, bagun√ßando tudo.

üß† Analogia simples:
Pense assim:

<mat-sidenav> = o menu fixo do lado.

<mat-sidenav-content> = a tela que muda conforme voc√™ navega.

<router-outlet> = o lugar onde essa "tela que muda" ser√° renderizada.

üß© Exemplo visual:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        mat-sidenav        ‚îÇ     mat-sidenav-content    ‚îÇ
‚îÇ     (menu lateral)        ‚îÇ                            ‚îÇ
‚îÇ   - In√≠cio                ‚îÇ   <router-outlet> aqui     ‚îÇ
‚îÇ   - Produtos              ‚îÇ   mostra os componentes    ‚îÇ
‚îÇ                           ‚îÇ   conforme a rota.         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üîö Resumindo:
O <mat-sidenav-content> serve para conter o conte√∫do principal que muda com a navega√ß√£o.

O <router-outlet> fica dentro dele porque voc√™ quer que os componentes das rotas apare√ßam ali, junto com o layout bonitinho da p√°gina.

Se ele estivesse fora, o conte√∫do n√£o estaria "dentro da estrutura do layout".


üí° Por que isso √© importante?
Porque com isso voc√™ consegue:

Manter o menu lateral fixo (<mat-sidenav>),

E ao mesmo tempo trocar apenas o conte√∫do do meio da tela, sem recarregar a p√°gina toda.

Aplicar estilos diferentes por rota, se quiser (por exemplo, mudar a cor do fundo dependendo do conte√∫do renderizado).

‚öôÔ∏è Quando o usu√°rio clica no menu:
O routerLink="/products" muda a rota para /products.

O Angular carrega o componente da rota correspondente.

Esse componente √© renderizado dentro do <router-outlet>, que est√° dentro do <mat-sidenav-content>.

Resultado: o menu continua igual, e s√≥ o conte√∫do da tela muda üéØ
_______________________________________________________________________________________________________________________________________________________________________

*OnInt: √â um ciclo de vida de inicializa√ß√£o, ou seja, que roda assim que o componente √© iniciado. M√©todo que sempre √© chamado automaticamente quando o componente √© inicializado.

_______________________________________________________________________________________________________________________________________________________________________

*Neste passo foi feita a cria√ß√£o do componente product-crud.component. Caminho:  views/product-crud

 O ProductCrudComponent n√£o √© o respons√°vel direto por criar ou listar produtos.
Ele √© um componente ‚Äúcontainer‚Äù, ou seja:

Ele organiza e centraliza a tela de produtos, e re√∫ne os componentes que fazem o CRUD de fato, como ProductRead, ProductCreate, etc.

üîß Analogia pr√°tica:
Imagine que seu sistema tem uma √°rea chamada "Produtos".
Essa √°rea precisa mostrar:

Um bot√£o de "Novo Produto"

Uma lista de produtos

(Talvez futuramente) filtros, ordena√ß√µes, ou abas

Tudo isso fica agrupado na rota /products, e quem monta essa tela principal √© o ProductCrudComponent.

‚úÖ Fun√ß√µes t√≠picas do ProductCrudComponent:
Fun√ß√£o	O que ele faz
Tela principal da √°rea "Produtos"	Respons√°vel por organizar tudo relacionado √† tela de produtos
Usa bot√£o para criar produtos	Tem um bot√£o que navega para /products/create
Mostra componentes filhos	Exibe ProductReadComponent para listar, por exemplo
Mant√©m o layout da √°rea	Serve como base para expandir no futuro (filtros, busca, etc.)

üß© Por que ele √© necess√°rio se j√° temos outros?
Porque ele serve como o ponto central da funcionalidade de produtos.
Se voc√™ fosse direto da home para ProductCreateComponent, voc√™ n√£o teria onde listar, navegar ou controlar o CRUD.
üß† Exemplo de rota:
/products ‚Üí mostra o ProductCrudComponent com o bot√£o + lista

/products/create ‚Üí vai para ProductCreateComponent com o formul√°rio

/products/update/:id ‚Üí (futuramente) pode ir para ProductUpdateComponent

‚úÖ Em resumo:
O ProductCrudComponent √© como uma "p√°gina principal da se√ß√£o de produtos".
Ele n√£o cria nem l√™ diretamente, mas re√∫ne os componentes que fazem isso e organiza o fluxo da tela.

üß© Agora, para esclarecer sua d√∫vida:
‚ùì Qual √© a utilidade do ProductCrudComponent?
Esse componente atua como um container (estrutura base) para o m√≥dulo de produtos.

Ele organiza a tela de produtos, geralmente com bot√£o de "criar" e espa√ßo para listar os produtos (tabela ou lista).
Ele n√£o faz o CRUD diretamente, mas centraliza o acesso √†s a√ß√µes como "listar" e "criar" produtos.
_______________________________________________________________________________________________________________________________________________________________________

* Neste passo criamos o product-create.component. Dentro de componentes/product/product-create. O ProductCreateComponent √© o componente respons√°vel por cadastrar (criar) um novo produto no sistema.
Ele exibe um formul√°rio com campos, e os bot√µes de salvar ou cancelar._______________________________________________________________________________________________________________________________________________________________________

*Neste passo foi criado um bot√£o usando MatButtonModule(foi importado no app.module) do Angular Material, dentro de product-crud.component para navegar para o product-create.component. Para isso dentro de  product-crud.component.ts importamos o Router,  e injetamos ele no construtor para podermos usar as rotas de app.routing.module:
-Importe do Router: import { Router } from '@angular/router';
-Linha do Construtor: constructor(private router: Router) { }
_______________________________________________________________________________________________________________________________________________________________________

*Neste passo, dentro de components/product criou um arquivo contendo uma classe(Interface) de Modelo no Angular(Model) chamada product.model.ts. Sempre que formos criar um produto, ele dever√° conter os atributos listados neste arquivo, sendo eles opcionais ou n√£o. Neste caso o id √© opcional, pois n√£o √© sempre que iremos precisar dele. Ou seja, quando n√≥s formos criar um produto, n√≥s somente iremos fornecer o nome e o pre√ßo sem fornecer um id, para quando eu mandar para o backend, ai sim ele ira me devolver um produto com id, nome e pre√ßo.
Quando n√≥s estivermos alterando, excluindo ou consultando um produto n√≥s vamos ter id, nome, pre√ßo.

-Para definir um atributo como opcional no TypesCript, √© usar o operador ? EXEMPLO: id?: number.

-EXPLICA√á√ÉO: Quando criamos nossas intera√ß√µes com o backend, neste caso quando a gente for mandar um produto para o backend, ou consumir um produto, n√≥s esperamos fazer isso a partir de um modelo que tem atributos bem definidos.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

PERGUNTA: POR QUE NUMA MODEL POR EXEMPLO DE PRODUTOS O ID SERIA OPCIONAL?

RESPOSTA: √ìtima pergunta! Em uma model (modelo) de produto no Angular/TypeScript, o id geralmente √© marcado como opcional (id?: number) por uma raz√£o muito pr√°tica relacionada √† cria√ß√£o de novos dados.

‚úÖ Explica√ß√£o simples
Quando voc√™ cria um novo produto, voc√™ ainda n√£o tem um id, porque:

O id normalmente √© gerado automaticamente pelo backend (ex: banco de dados).

No momento da cria√ß√£o (antes de salvar), seu objeto ainda n√£o tem esse valor.

üß† Exemplo real
Model de Produto:

export interface Product {
  id?: number;          // ID opcional
  name: string;
  price: number;
}


Criando um novo produto no Angular:

const novoProduto: Product = {
  name: 'Mouse Gamer',
  price: 199.90,
  // sem id!
};

Quando voc√™ envia isso para a API usando POST, o backend insere no banco e gera um id automaticamente, e ent√£o pode te retornar o produto completo com id preenchido.

üß© Se o id n√£o fosse opcional?
Voc√™ teria que sempre fornecer um id, o que n√£o faz sentido ao criar algo novo ‚Äî j√° que o frontend n√£o sabe qual ser√° o pr√≥ximo ID.

‚úÖ Em resumo:
Situa√ß√£o			O que acontece?
Criar novo item			O id √© omitido (opcional)
Editar item existente		O id j√° existe e √© usado normalmente
id n√£o for opcional		Voc√™ teria que colocar um valor falso ou inv√°lido

_______________________________________________________________________________________________________________________________________________________________________

*Nesta passo fizemos a cria√ß√£o do Service, dentro de componentes/product, criamos o product.service.ts e importamos o HttpClientModule dentro do app.module para podermos fazer requisi√ß√µes Http.
_______________________________________________________________________________________________________________________________________________________________________

EXPLICA√á√ÉO DO M√âTODO create PARA CRIAR UM PRODUTO VIA POST NO SERVICE:

*Neste passo, criamos um m√©todo respons√°vel por cadastrar um novo produto na API. Primeiro, importamos o HttpClient do Angular e o injetamos no construtor da classe (por meio da inje√ß√£o de depend√™ncia). Em seguida, declaramos o atributo baseUrl, que armazena a URL base da API: 'http://localhost:3100/products'.

O m√©todo create recebe como par√¢metro um objeto do tipo Product (modelo de produto) e retorna um Observable<Product>, que representa a resposta da requisi√ß√£o HTTP.

Dentro do m√©todo, utilizamos o m√©todo post do HttpClient, passando como argumentos a URL da API (this.baseUrl) e o objeto product. Isso realiza uma requisi√ß√£o POST para cadastrar o produto no backend.

*M√âTODO QUE ESTA O SERVICE
create(product: Product): Observable<Product> {
  return this.http.post<Product>(this.baseUrl, product);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

EXPLICA√á√ÉO DO M√âTODO createProduct DO COMPONENTE:
Este m√©todo √© respons√°vel por acionar a cria√ß√£o de um novo produto quando o usu√°rio envia o formul√°rio (por exemplo, clicando em "Salvar").

Chamada do service:
O m√©todo chama o create do productService, passando o objeto this.product, que representa o produto preenchido pelo usu√°rio.

Inscri√ß√£o (subscribe):
Como o m√©todo create retorna um Observable, usamos .subscribe() para esperar a resposta da API e executar a√ß√µes ap√≥s a cria√ß√£o do produto.

Mensagem de confirma√ß√£o:
Dentro do .subscribe(), logo ap√≥s a confirma√ß√£o de que o produto foi criado com sucesso, chamamos productService.showMessage('Produto criado!').
Essa fun√ß√£o geralmente exibe uma notifica√ß√£o visual para o usu√°rio (como um MatSnackBar).

Navega√ß√£o:
Em seguida, usamos o this.router.navigate(['/products']) para redirecionar o usu√°rio de volta para a lista de produtos, ap√≥s o cadastro.

C√ìDIO DO M√âTODO createProduct QUE ESTA NO TS O COMPONENTE:

createProduct(): void {
  this.productService.create(this.product).subscribe(() => {
    this.productService.showMessage('Produto criado!'); 
    this.router.navigate(['/products']); 
  });
}

‚úÖ Resumo do que ele faz:
Etapa				A√ß√£o
1. Chama o service		this.productService.create(...) envia o produto para a API
2. Espera a resposta		.subscribe(...) aguarda o resultado da opera√ß√£o
3. Exibe mensagem		showMessage('Produto criado!') avisa o usu√°rio
4. Redireciona a p√°gina		this.router.navigate(['/products']) leva o usu√°rio para a listagem
_______________________________________________________________________________________________________________________________________________________________________

*PERGUNTA: POR QUE NA SE√á√ÉO DE PROPRIEDADES DA CLASSE  DO COMPONENTE ESSE M√âTODO FOI CRIADO FOI COLOCADO ISSO?:
product: Product = {
    name: '',
    price: null
  }

√ìtima d√∫vida! Essa parte que voc√™ viu:

TS:

product: Product = {
  name: '',
  price: null
}
est√° na se√ß√£o de propriedades da classe do componente, e √© muito importante para que o formul√°rio funcione corretamente no Angular.

‚úÖ Por que isso est√° ali?
Essa linha declara e inicializa o objeto product, que ser√° usado no formul√°rio (ex: no [(ngModel)] ou no formControlName).

Motivos principais:
Evita erro de undefined no template:
Se o Angular tentasse acessar product.name ou product.price no HTML e product n√£o estivesse definido, daria erro na renderiza√ß√£o.

Cria um produto "vazio" para preencher o formul√°rio:
Serve como estrutura base para o usu√°rio digitar os dados. Depois de preenchido, ele ser√° enviado no this.productService.create(this.product).

Garante que o product est√° no formato do model:
Como ele √© do tipo Product, o TypeScript ajuda a garantir que voc√™ est√° trabalhando com os campos corretos (name, price, etc).

üîç Exemplo visual:
Model:

export interface Product {
  id?: number;
  name: string;
  price: number;
}


Componente:

export class ProductCreateComponent {
  product: Product = {
    name: '',
    price: null
  };
}

HTML (template):

<input [(ngModel)]="product.name" placeholder="Nome">
<input [(ngModel)]="product.price" type="number" placeholder="Pre√ßo">

üëâ Como product j√° est√° inicializado, o Angular consegue ligar o formul√°rio com o objeto, e depois voc√™ pode simplesmente chamar:

TS: this.productService.create(this.product)

‚úÖ Resumo:
Por que inicializar product?	  Para qu√™ serve?
Evitar erro de undefined	  O template precisa do objeto definido para funcionar
Preparar objeto para envio	  J√° fica pronto para enviar no m√©todo create()
Ajudar o TypeScript com tipagem	  Garante que est√° seguindo a interface Product

-OBS: Essa forma onde usa [(ngModel)] no HTML e um objeto product no componente √© chamada de Template-driven Forms.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


 **VAMOS VER COMO CRIAR E USAR UM FORMUL√ÅRIO REATIVO (REACTIVE FORMS) NO ANGULAR, PASSO A PASSO, USANDO O MESMO EXEMPLO DE PRODUCT (PODUCT COM NAME E PRICE).

‚úÖ 1. Pr√©-requisitos
No seu m√≥dulo (app.module.ts ou outro onde est√° o componente), voc√™ precisa importar:

import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  imports: [
    ReactiveFormsModule
  ]
})

export class AppModule { }
----------------------------------------------------------------------------------------------------

‚úÖ 2. Model de Produto (interface)

export interface Product {
  id?: number;
  name: string;
  price: number;
}

----------------------------------------------------------------------------------------------------
‚úÖ 3. Componente: configurando o FormGroup

import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { ProductService } from '../product.service';

@Component({
  selector: 'app-product-create',
  templateUrl: './product-create.component.html'
})

export class ProductCreateComponent {
  form: FormGroup;

  constructor(
    private fb: FormBuilder,
    private productService: ProductService,
    private router: Router
  ) {
    // Criando o formul√°rio com valida√ß√µes
    this.form = this.fb.group({
      name: ['', Validators.required],
      price: [null, [Validators.required, Validators.min(0.01)]]
    });
  }

  createProduct(): void {
    if (this.form.valid) {
      this.productService.create(this.form.value).subscribe(() => {
        this.productService.showMessage('Produto criado!');
        this.router.navigate(['/products']);
      });
    }
  }
}
----------------------------------------------------------------------------------------------------
‚úÖ 4. HTML do formul√°rio (product-create.component.html)

<form [formGroup]="form" (ngSubmit)="createProduct()">
  <label for="name">Nome</label>
  <input id="name" formControlName="name" type="text">
  <div *ngIf="form.controls['name'].invalid && form.controls['name'].touched">
    Nome √© obrigat√≥rio.
  </div>

  <label for="price">Pre√ßo</label>
  <input id="price" formControlName="price" type="number">
  <div *ngIf="form.controls['price'].invalid && form.controls['price'].touched">
    Pre√ßo √© obrigat√≥rio e deve ser maior que zero.
  </div>

  <button type="submit" [disabled]="form.invalid">Salvar</button>
</form>

‚úÖ Vantagens do Reactive Forms:

Vantagem					Explica√ß√£o
Valida√ß√£o mais controlada			Voc√™ pode acessar os estados (valid, touched, dirty, etc.) facilmente
Escal√°vel					Mais f√°cil de montar formul√°rios grandes e din√¢micos
Integra melhor com servi√ßos			Pode passar form.value diretamente pro backend
N√£o precisa inicializar product manualmente	O FormGroup j√° cuida disso


‚úÖ Resumo geral:
O que voc√™ faz?					Com Template-driven				Com Reactive Forms
Cria o objeto de produto vazio			product: Product = {...}			form: FormGroup com FormBuilder
Liga o formul√°rio				[(ngModel)]="product.name"			[formGroup] + formControlName
Envia para API					this.productService.create(this.product)	this.productService.create(this.form.value)



_______________________________________________________________________________________________________________________________________________________________________

*Neste passo criamos o formul√°rio para criar um produto dentro de product-create. Nesse passo para trabalhar com formul√°rios, foi necess√°rio importar dentro  de app.module (e colocar em imports tamb√©m)os seguintes m√≥dulos:

import  { FormsModule }  from '@angular/forms'
import  { MatFormFieldModule }  from '@angular/material/form-field';
import  { MatInputModule }  from '@angular/material/input';
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------* FORMULARIO: ‚úÖ Explica√ß√£o geral
Esse formul√°rio √© um formul√°rio simples de cadastro de produto, feito com:

Template-driven forms (usa [(ngModel)])

Angular Material (componentes estilizados)

HTML estruturado dentro de um <mat-card> para visual mais moderno

<mat-card>
    <mat-card-title>Novo Produto</mat-card-title>
    <form>
        <mat-form-field>
            <input matInput placeholder="Nome" [(ngModel)]="product.name" name="name">
        </mat-form-field>
        <mat-form-field>
            <input matInput placeholder="Pre√ßo (R$)" [(ngModel)]="product.price" name="price">
        </mat-form-field>
    </form>
    <button mat-raised-button color="primary" (click)="createProduct()">Salvar</button>
    <button mat-raised-button color="warn" (click)="cancel()">Cancelar</button>
</mat-card>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

üß± Explica√ß√£o por partes:
1. Container visual do Angular Material

<mat-card>
  <mat-card-title>Novo Produto</mat-card-title>
<mat-card>: Cria um cart√£o visual com sombra, bordas e padding.

<mat-card-title>: Define o t√≠tulo do cart√£o: "Novo Produto".
-----------------------------------------------------------------------------------------
2. Formul√°rio (template-driven)

<form>
  <mat-form-field>
    <input matInput placeholder="Nome" [(ngModel)]="product.name" name="name">
  </mat-form-field>

  <mat-form-field>
    <input matInput placeholder="Pre√ßo (R$)" [(ngModel)]="product.price" name="price">
  </mat-form-field>
</form>

Detalhes:
<form>: Elemento HTML de formul√°rio (ainda sem (ngSubmit) ‚Äî isso poderia ser adicionado para enviar com Enter).

<mat-form-field>: Componente do Angular Material que estiliza o campo de entrada.

<input matInput>: Campo de texto com estilo Material.

[(ngModel)]="product.name": Faz data binding (liga√ß√£o) entre o input e a propriedade product.name da classe do componente.

name="name": Obrigat√≥rio no template-driven para que o Angular trate corretamente o campo.

‚ö†Ô∏è Importante: Esse formul√°rio √© template-driven, porque usa [(ngModel)]. O Angular vai atualizar this.product automaticamente √† medida que o usu√°rio digita.
-----------------------------------------------------------------------------------------
3. Bot√µes de a√ß√£o

<button mat-raised-button color="primary" (click)="createProduct()">Salvar</button>
<button mat-raised-button color="warn" (click)="cancel()">Cancelar</button>

Detalhes:
mat-raised-button: Cria um bot√£o elevado com sombra (Material Design).

color="primary": Estiliza o bot√£o com a cor principal do tema (geralmente azul).

color="warn": Estiliza com a cor de alerta (geralmente vermelho).

(click)="createProduct()": Chama o m√©todo createProduct() no componente quando clicado.

(click)="cancel()": Chama o m√©todo cancel() no componente (geralmente para voltar ou limpar o formul√°rio).

üîÅ Fluxo completo do formul√°rio:
O usu√°rio digita o nome e pre√ßo.

O Angular atualiza automaticamente o objeto product via [(ngModel)].

Quando o usu√°rio clica em "Salvar", o m√©todo createProduct() √© chamado.

Esse m√©todo usa this.productService.create(this.product) para enviar os dados √† API.

‚úÖ Resumo:
Parte							O que faz
<mat-card>						Organiza visualmente o formul√°rio
[(ngModel)]						Faz a liga√ß√£o entre o input e o objeto product
name="..."						Necess√°rio no template-driven forms para controle de estado
(click)="..."						Dispara m√©todos no componente quando os bot√µes s√£o clicados
Angular Material (matInput, mat-form-field, etc.)	D√° apar√™ncia moderna e profissional ao formul√°rio



_______________________________________________________________________________________________________________________________________________________________________


*Neste passo foi criado o componente de listagem dos produtos  dentro de components/product/product-read.

M√âTODO READ DO SERVICE: 
-Chama a API usando o HttpClient do Angular.

-Faz uma requisi√ß√£o GET para a URL armazenada em this.baseUrl (ex: 'http://localhost:3000/products').

-Espera receber uma lista de produtos (Product[]) como resposta.

-Retorna um Observable, que √© como uma "promessa que avisa quando a resposta chegar".

-Esse Observable ser√° usado com .subscribe() para obter os dados.


read(): Observable<Product[]> {
    return this.http.get<Product[]>(this.baseUrl)
  }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*USANDO O M√âTODO READ DENTRO DO COMPONENTE DE LISTAGEM DE PRODUTOS: product-read

export class ProductReadComponent implements OnInit {

  products:Product[]

  constructor(private productService: ProductService) { }

  ngOnInit(): void {
    this.productService.read().subscribe(products => {
      this.products = products
      console.log(products)
    })
  }


üìå O que ele faz?
Declara products: Product[] para armazenar os produtos.

Injeta o ProductService no construtor.

No ngOnInit(), chama o m√©todo read() do service para buscar todos os produtos da API.

Quando os dados chegam, atribui √† vari√°vel products, que ser√° usada no HTML (ex: com *ngFor).

_______________________________________________________________________________________________________________________________________________________________________


*Neste passo foi sugerido uma forma de criar os componentes de uma maneira mais simples utilizando angular material schematics. √â s√≥ entrar no site: https://v6.material.angular.dev/guide/schematics.

-Comando: ng generate @angular/material:table components/product/product-read2. Neste caso criamos apenas uma tabela de exemplo usando shematics do angular material, que gera um componente inteiro automaticamente. A tabela de exemplo j√° vem com os m√≥dulos m√≥dulo da tabela, o de ordena√ß√£o, pagina√ß√£o,  e eles  j√° s√£o importados no appmodule automaticamente.

-Existem outros tipos de shematic como:  Navigation Schematic, Dashboard Schematic, Table Schematic, cada um com seu respectivo comando e cria√ß√£o. Ou seja, podemos usar os schematics para gerar componentes prontos, e a partir desses componentes prontos, n√≥s conseguimos criar nossos componentes de uma forma muito simples.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*ENTENDENDO O COMPONENTE PRONTO  DE UMA TABELA QUE FOI GERADO UTILIZANDO OS SCHEMATICS DO ANGULAR MATERIAL:
- O nome do componente √©: product-read2. E foi gerado no caminho: componentes/product/product-read2

-PERGUNTA: Como √© que os componentes paginator, sort(que est√£o dentro de produt-read2-datasource) s√£o colocados dentro do componente data source, j√° que o construtor n√£o recebe nenhum par√¢metro? R: Dentro do componente product-read2.component.ts, tem o decorator @ViewChild.

-@ViewChild: √â o filho da minha tela-template-view-vis√£o, e nele √© passado o tipo de componente que voc√™ quer que seja selecionado, e ele vai percorrer o HTML, vai ver onde esta o componente, Exemplo: @ViewChild(MatPaginator) paginator: MatPaginator, e vai pegar o primeiro componente paginator e colocar dentro da vari√°vel paginator. Ou seja, quando  voc√™ usa o decorator @ViewChild encima de uma vari√°vel o pr√≥prio Angular vai percorrer o seu template e vai pegar a primeira ocorr√™ncia desse componente. Ele vai entrar no HTML  e vai perceber eu existe o elemento paginator, vai pegar a instancia desse elemento e vai jogar para a vari√°vel dentro do TS,de tal forma que quem vai respons√°vel por resolver esse atributo paginator: MatPaginator √© o Angular a partir desse decorator @ViewChild.Essa √© forma que conseguimos pegar da nossa view(HTM) os elementos: paginator,sort e table.


-EXEMPLO DIRETO DO CODIGO:
export class ProductRead2Component implements AfterViewInit, OnInit {
  @ViewChild(MatPaginator) paginator: MatPaginator;
  @ViewChild(MatSort) sort: MatSort;
  @ViewChild(MatTable) table: MatTable<Product>;
  dataSource: ProductRead2DataSource;

ngOnInit() {
    this.dataSource = new ProductRead2DataSource();
  }
ngAfterViewInit() {
    this.dataSource.sort = this.sort;
    this.dataSource.paginator = this.paginator;
    this.table.dataSource = this.dataSource; // Aqui seta os dados da tabela, se essa linha for comentada os dados n√£o s√£o mais exibidos na tabela.
  }

-O elemento dataSource esta sendo criado no ngOnInit, e depois que a tela √© inicializada ap√≥s todos os componentes serem instanciados na tela, ai sim ele vai pegar setar os atributos dentro de ngAfterViewInit, fazendo a liga√ß√£o tanto do sort e paginator dentro do dataSource, como ele atribui o dataSource para a tabela, ai sim os dados s√£o renderizados.


- No HTML podemos usar um property binding [dataSource]= "" no HTML pra mostrar os dados tamb√©m.
EXEMPLO:  <table mat-table class="full-width-table" matSort aria-label="Elements" [dataSource]="dataSource.data">


- No TS tem um atributo que s√£o as colunas que est√£o vis√≠veis na tabela: displayedColumns = ['id', 'name']; 

- E no HTML ele usa as diretivas que cria o cabe√ßalho da tabela que mostra as colunas que ser√£o exibidas: <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>


- Esse mostra os dados da tabela:<tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

- Defini√ß√£o e colunas da tabela: O nomes de  matColumnDef precisa ser exatamente nomes que est√£o no displayedColumns. Exemplo: displayedColumns = ['id', 'name']; por sua vez matColumnDef="id" e matColumnDef="name"


-EXEMPLO DE C√ìDIGO DE COLUNAS DE UMA TABELA.
<!-- Id Column -->
    <ng-container matColumnDef="id">
      <th mat-header-cell *matHeaderCellDef mat-sort-header>Id</th>
      <td mat-cell *matCellDef="let row">{{row.id}}</td>  
    </ng-container>

    <!-- Name Column -->
    <ng-container matColumnDef="name">
      <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
      <td mat-cell *matCellDef="let row">{{row.name}}</td>
    </ng-container>

- ng-container √© um agrupador de elementos, onde definimos como vai ser o cabe√ßalho da coluna e como vai ser o conte√∫do da coluna:
<!-- Id Column -->
    <ng-container matColumnDef="id">
      <th mat-header-cell *matHeaderCellDef mat-sort-header>Id</th>
      <td mat-cell *matCellDef="let row">{{row.id}}</td>
    </ng-container>


//OBS: A vari√°vel row √© somente para representar as linhas a tabela, pode ser qualquer nome e n√£o precisa ser o mesmo nome que esta dentro de {{}}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*OU SEJA ESSA PARTE SERIA O TEMPLATE DE CADA COLUNA:

<!-- Id Column -->
    <ng-container matColumnDef="id">
      <th mat-header-cell *matHeaderCellDef mat-sort-header>Id</th>
      <td mat-cell *matCellDef="let prod">{{row.id}}</td>
    </ng-container>

    <!-- Name Column -->
    <ng-container matColumnDef="name">
      <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
      <td mat-cell *matCellDef="let prod">{{row.name}}</td>
    </ng-container>

---------------------------------------------------------------------------------
*E ESSE SERIA O TEMPLATE DA TABELA TODA:

<tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>  --Define quais colunas ser√£o exibidas no cabe√ßalho
<tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr> --Define quais colunas ser√£o exibidas nos dados e tem um vari√°vel row pra cada uma das linhas da tabela.

_______________________________________________________________________________________________________________________________________________________________________

**Neste passo criamos de fato a tabela de listagem de produtos, criamos o displayedColumns com os nomes das colunas: displayedColumns= ['id', 'name', 'price'];
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Criamos uma lista de produtos: products:Product[];
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Chamamos  m√©todo read no ngOnInit, ou seja sempre que a pagina de listagem de produtos for carregada, os produtos tamb√©m ser√£o carregados:
ngOnInit(): void { //M√©todo que sempre √© chamado automaticamente quando o componente √© inicializado.
    this.productService.read().subscribe(products => {
      this.products = products;          
    })
  } 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------


-DataSource: Origem de dados.

-Property Binding DataSource: Vinculamos os produtos, displayedColumns e a tabela, mostrando os dados na tabela.
<table mat-table [dataSource]="products">
_______________________________________________________________________________________________________________________________________________________________________


**Neste passo colocamos mais uma coluna de a√ß√µes na tabela de produtos com √≠cones de editar e excluir que ser√£o usados para chamar os componentes de edi√ß√£o e exclus√£o. Esses √≠cones ir√£o funcionar como se fossem bot√µes.



_______________________________________________________________________________________________________________________________________________________________________

**Neste passo, criamos os m√©todos



_______________________________________________________________________________________________________________________________________________________________________






_______________________________________________________________________________________________________________________________________________________________________




_______________________________________________________________________________________________________________________________________________________________________



_______________________________________________________________________________________________________________________________________________________________________



_______________________________________________________________________________________________________________________________________________________________________




_______________________________________________________________________________________________________________________________________________________________________






























































*EXEMPLO DE M√âTODO PARA USAR SNACKBAR (COMO FOI FEITO NO NOSSO SERVICE)
showMessage(msg: string): void {
    this.snackbar.open(msg,'X', { //o par√¢metro action esta com X que serve para fechar o snackbar(pode colocar qualquer texto, se ficar vazio voc√™ ter√° que experaroduratn terminar)
      duration: 3000,  //dura√ß√£o de 3 segundos
      horizontalPosition: "right", //posi√ß√£o horizontal a direita
      verticalPosition: "top"  //posi√ß√£o vertical em cima
    })
  }


_______________________________________________________________________________________________________________________________________________________________________





